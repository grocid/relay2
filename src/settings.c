/* settings.c generated by valac 0.34.4, the Vala compiler
 * generated from settings.vala, do not modify */

/* -*- Mode: vala; indent-tabs-mode: nil; c-basic-offset: 4; tab-width: 4 -*-  */
/*
 * settings.vala
 * Copyright (C) 2015 Kyle Agronick <agronick@gmail.com>
 *
 * Relay is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * Relay is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <glib/gi18n-lib.h>
#include <pango/pango.h>
#include <math.h>


#define TYPE_SETTINGS (settings_get_type ())
#define SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SETTINGS, Settings))
#define SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SETTINGS, SettingsClass))
#define IS_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SETTINGS))
#define IS_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SETTINGS))
#define SETTINGS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SETTINGS, SettingsClass))

typedef struct _Settings Settings;
typedef struct _SettingsClass SettingsClass;
typedef struct _SettingsPrivate SettingsPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
typedef struct _Block21Data Block21Data;
typedef struct _Block22Data Block22Data;
#define __vala_PangoFontDescription_free0(var) ((var == NULL) ? NULL : (var = (_vala_PangoFontDescription_free (var), NULL)))

struct _Settings {
	GObject parent_instance;
	SettingsPrivate * priv;
};

struct _SettingsClass {
	GObjectClass parent_class;
};

struct _SettingsPrivate {
	GeeHashMap* colors_defaults;
	GSettings* settings;
	GtkWindow* window;
};

struct _Block21Data {
	int _ref_count_;
	Settings* self;
	gchar* type;
	GtkEntry* colors;
};

struct _Block22Data {
	int _ref_count_;
	Block21Data * _data21_;
	GtkColorChooserDialog* picker;
};


static gpointer settings_parent_class = NULL;
extern gboolean relay_is_light_theme;

GType settings_get_type (void) G_GNUC_CONST;
#define SETTINGS_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_SETTINGS, SettingsPrivate))
enum  {
	SETTINGS_DUMMY_PROPERTY
};
gboolean settings_show_window (Settings* self);
gchar* relay_get_asset_file (const gchar* name);
#define MAIN_WINDOW_UI_FILE_SETTINGS "ui/settings_window.ui"
static gboolean __lambda11_ (Settings* self, gboolean state);
static gboolean ___lambda11__gtk_switch_state_set (GtkSwitch* _sender, gboolean state, gpointer self);
static Block21Data* block21_data_ref (Block21Data* _data21_);
static void block21_data_unref (void * _userdata_);
static gboolean ____lambda12_ (Block21Data* _data21_, GdkEventButton* event);
static Block22Data* block22_data_ref (Block22Data* _data22_);
static void block22_data_unref (void * _userdata_);
static void __lambda13_ (Block22Data* _data22_, gint id);
gchar* settings_RGBA_to_hex (GdkRGBA* rgba);
static void ___lambda13__gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self);
static gboolean _____lambda12__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static void ____lambda14_ (Block21Data* _data21_);
static void _____lambda14__gtk_editable_changed (GtkEditable* _sender, gpointer self);
static gboolean ____lambda15_ (Block21Data* _data21_, GdkEventButton* event);
static gboolean _____lambda15__gtk_widget_button_release_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static void _vala_PangoFontDescription_free (PangoFontDescription* self);
static gboolean __lambda16_ (Settings* self, GdkEventButton* event);
static gboolean ___lambda16__gtk_widget_button_release_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
gchar* settings_get_color (Settings* self, const gchar* color);
gboolean settings_get_bool (Settings* self, const gchar* name);
void settings_set_colors_defaults (Settings* self);
Settings* settings_new (void);
Settings* settings_construct (GType object_type);
static GObject * settings_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void settings_finalize (GObject* obj);

static const gchar* SETTINGS_switch_names[8] = {"show_animations", "show_join", "show_sidebar", "open_server", "show_datestamp", "change_tab", "show_tabs", "show_line"};
static const gchar* SETTINGS_color_names[5] = {"user-self-color", "user-other-color", "message-color", "link-color", "timestamp-color"};

static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	{
		GRegex* regex = NULL;
		const gchar* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		GRegex* _tmp3_ = NULL;
		GRegex* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		GRegex* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		_tmp0_ = old;
		_tmp1_ = g_regex_escape_string (_tmp0_, -1);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_regex_new (_tmp2_, 0, 0, &_inner_error_);
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		regex = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch17_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp6_ = regex;
		_tmp7_ = replacement;
		_tmp8_ = g_regex_replace_literal (_tmp6_, self, (gssize) -1, 0, _tmp7_, 0, &_inner_error_);
		_tmp5_ = _tmp8_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch17_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp9_ = _tmp5_;
		_tmp5_ = NULL;
		result = _tmp9_;
		_g_free0 (_tmp5_);
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally17;
	__catch17_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally17:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


static gboolean __lambda11_ (Settings* self, gboolean state) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	_tmp0_ = state;
	g_signal_emit_by_name (self, "show-hide-tabs", _tmp0_);
	result = TRUE;
	return result;
}


static gboolean ___lambda11__gtk_switch_state_set (GtkSwitch* _sender, gboolean state, gpointer self) {
	gboolean result;
	result = __lambda11_ ((Settings*) self, state);
	return result;
}


static Block21Data* block21_data_ref (Block21Data* _data21_) {
	g_atomic_int_inc (&_data21_->_ref_count_);
	return _data21_;
}


static void block21_data_unref (void * _userdata_) {
	Block21Data* _data21_;
	_data21_ = (Block21Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data21_->_ref_count_)) {
		Settings* self;
		self = _data21_->self;
		_g_object_unref0 (_data21_->colors);
		_g_free0 (_data21_->type);
		_g_object_unref0 (self);
		g_slice_free (Block21Data, _data21_);
	}
}


static Block22Data* block22_data_ref (Block22Data* _data22_) {
	g_atomic_int_inc (&_data22_->_ref_count_);
	return _data22_;
}


static void block22_data_unref (void * _userdata_) {
	Block22Data* _data22_;
	_data22_ = (Block22Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data22_->_ref_count_)) {
		Settings* self;
		self = _data22_->_data21_->self;
		_g_object_unref0 (_data22_->picker);
		block21_data_unref (_data22_->_data21_);
		_data22_->_data21_ = NULL;
		g_slice_free (Block22Data, _data22_);
	}
}


static void __lambda13_ (Block22Data* _data22_, gint id) {
	Block21Data* _data21_;
	Settings* self;
	gint _tmp0_ = 0;
	GtkColorChooserDialog* _tmp6_ = NULL;
	_data21_ = _data22_->_data21_;
	self = _data21_->self;
	_tmp0_ = id;
	if (_tmp0_ == ((gint) GTK_RESPONSE_OK)) {
		GtkEntry* _tmp1_ = NULL;
		GtkColorChooserDialog* _tmp2_ = NULL;
		GdkRGBA _tmp3_ = {0};
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		_tmp1_ = _data21_->colors;
		_tmp2_ = _data22_->picker;
		gtk_color_chooser_get_rgba ((GtkColorChooser*) _tmp2_, &_tmp3_);
		_tmp4_ = settings_RGBA_to_hex (&_tmp3_);
		_tmp5_ = _tmp4_;
		gtk_entry_set_text (_tmp1_, _tmp5_);
		_g_free0 (_tmp5_);
	}
	_tmp6_ = _data22_->picker;
	g_signal_emit_by_name ((GtkDialog*) _tmp6_, "close");
}


static void ___lambda13__gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self) {
	__lambda13_ (self, response_id);
}


static gboolean ____lambda12_ (Block21Data* _data21_, GdkEventButton* event) {
	Settings* self;
	gboolean result = FALSE;
	Block22Data* _data22_;
	GdkEventButton* _tmp0_ = NULL;
	guint _tmp1_ = 0U;
	const gchar* _tmp2_ = NULL;
	GtkWindow* _tmp3_ = NULL;
	GtkColorChooserDialog* _tmp4_ = NULL;
	GtkColorChooserDialog* _tmp5_ = NULL;
	GdkRGBA color = {0};
	GtkEntry* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	GtkColorChooserDialog* _tmp9_ = NULL;
	GdkRGBA _tmp10_ = {0};
	GtkColorChooserDialog* _tmp11_ = NULL;
	self = _data21_->self;
	g_return_val_if_fail (event != NULL, FALSE);
	_data22_ = g_slice_new0 (Block22Data);
	_data22_->_ref_count_ = 1;
	_data22_->_data21_ = block21_data_ref (_data21_);
	_tmp0_ = event;
	_tmp1_ = _tmp0_->button;
	if (_tmp1_ != ((guint) 1)) {
		result = TRUE;
		block22_data_unref (_data22_);
		_data22_ = NULL;
		return result;
	}
	_tmp2_ = _ ("Color Picker");
	_tmp3_ = self->priv->window;
	_tmp4_ = (GtkColorChooserDialog*) gtk_color_chooser_dialog_new (_tmp2_, _tmp3_);
	g_object_ref_sink (_tmp4_);
	_data22_->picker = _tmp4_;
	_tmp5_ = _data22_->picker;
	g_signal_connect_data ((GtkDialog*) _tmp5_, "response", (GCallback) ___lambda13__gtk_dialog_response, block22_data_ref (_data22_), (GClosureNotify) block22_data_unref, 0);
	memset (&color, 0, sizeof (GdkRGBA));
	_tmp6_ = _data21_->colors;
	_tmp7_ = gtk_entry_get_text (_tmp6_);
	_tmp8_ = _tmp7_;
	gdk_rgba_parse (&color, _tmp8_);
	_tmp9_ = _data22_->picker;
	_tmp10_ = color;
	gtk_color_chooser_set_rgba ((GtkColorChooser*) _tmp9_, &_tmp10_);
	_tmp11_ = _data22_->picker;
	gtk_widget_show_all ((GtkWidget*) _tmp11_);
	result = TRUE;
	block22_data_unref (_data22_);
	_data22_ = NULL;
	return result;
}


static gboolean _____lambda12__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = ____lambda12_ (self, event);
	return result;
}


static void ____lambda14_ (Block21Data* _data21_) {
	Settings* self;
	GtkEntry* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	GdkRGBA bg = {0};
	GtkEntry* _tmp8_ = NULL;
	const gchar* _tmp9_ = NULL;
	const gchar* _tmp10_ = NULL;
	GtkEntry* _tmp11_ = NULL;
	GdkRGBA _tmp12_ = {0};
	self = _data21_->self;
	_tmp0_ = _data21_->colors;
	_tmp1_ = gtk_entry_get_text (_tmp0_);
	_tmp2_ = _tmp1_;
	if (g_strcmp0 (_tmp2_, "default") == 0) {
		GtkEntry* _tmp3_ = NULL;
		GeeHashMap* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		gpointer _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		_tmp3_ = _data21_->colors;
		_tmp4_ = self->priv->colors_defaults;
		_tmp5_ = _data21_->type;
		_tmp6_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp4_, _tmp5_);
		_tmp7_ = (gchar*) _tmp6_;
		gtk_entry_set_text (_tmp3_, _tmp7_);
		_g_free0 (_tmp7_);
	}
	memset (&bg, 0, sizeof (GdkRGBA));
	_tmp8_ = _data21_->colors;
	_tmp9_ = gtk_entry_get_text (_tmp8_);
	_tmp10_ = _tmp9_;
	gdk_rgba_parse (&bg, _tmp10_);
	_tmp11_ = _data21_->colors;
	_tmp12_ = bg;
	gtk_widget_override_color ((GtkWidget*) _tmp11_, GTK_STATE_FLAG_NORMAL, &_tmp12_);
	g_signal_emit_by_name (self, "changed-color");
}


static void _____lambda14__gtk_editable_changed (GtkEditable* _sender, gpointer self) {
	____lambda14_ (self);
}


static gboolean ____lambda15_ (Block21Data* _data21_, GdkEventButton* event) {
	Settings* self;
	gboolean result = FALSE;
	GtkEntry* _tmp0_ = NULL;
	self = _data21_->self;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = _data21_->colors;
	gtk_entry_set_text (_tmp0_, "default");
	result = FALSE;
	return result;
}


static gboolean _____lambda15__gtk_widget_button_release_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = ____lambda15_ (self, event);
	return result;
}


static void _vala_PangoFontDescription_free (PangoFontDescription* self) {
	g_boxed_free (pango_font_description_get_type (), self);
}


static gboolean __lambda16_ (Settings* self, GdkEventButton* event) {
	gboolean result = FALSE;
	GtkWindow* _tmp0_ = NULL;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = self->priv->window;
	gtk_window_close (_tmp0_);
	result = TRUE;
	return result;
}


static gboolean ___lambda16__gtk_widget_button_release_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = __lambda16_ ((Settings*) self, event);
	return result;
}


gboolean settings_show_window (Settings* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	GtkWindow* _tmp1_ = NULL;
	GtkBuilder* builder = NULL;
	GtkBuilder* _tmp6_ = NULL;
	GtkBuilder* _tmp14_ = NULL;
	GObject* _tmp15_ = NULL;
	GtkWindow* _tmp16_ = NULL;
	GtkSwitch* show_tabs = NULL;
	GtkBuilder* _tmp27_ = NULL;
	GObject* _tmp28_ = NULL;
	GtkSwitch* _tmp29_ = NULL;
	GtkSwitch* _tmp30_ = NULL;
	GtkButton* close = NULL;
	GtkBuilder* _tmp60_ = NULL;
	GObject* _tmp61_ = NULL;
	GtkButton* _tmp62_ = NULL;
	GtkButton* _tmp63_ = NULL;
	GtkWindow* _tmp64_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = self->priv->window;
	if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, gtk_widget_get_type ())) {
		GtkWindow* _tmp2_ = NULL;
		gboolean _tmp3_ = FALSE;
		gboolean _tmp4_ = FALSE;
		_tmp2_ = self->priv->window;
		_tmp3_ = gtk_widget_get_visible ((GtkWidget*) _tmp2_);
		_tmp4_ = _tmp3_;
		_tmp0_ = _tmp4_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		GtkWindow* _tmp5_ = NULL;
		_tmp5_ = self->priv->window;
		gtk_window_present (_tmp5_);
		result = TRUE;
		return result;
	}
	_tmp6_ = gtk_builder_new ();
	builder = _tmp6_;
	{
		GtkBuilder* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		_tmp7_ = builder;
		_tmp8_ = relay_get_asset_file (MAIN_WINDOW_UI_FILE_SETTINGS);
		_tmp9_ = _tmp8_;
		gtk_builder_add_from_file (_tmp7_, _tmp9_, &_inner_error_);
		_g_free0 (_tmp9_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch16_g_error;
		}
	}
	goto __finally16;
	__catch16_g_error:
	{
		GError* e = NULL;
		gchar* _tmp10_ = NULL;
		gchar* _tmp11_ = NULL;
		gchar* _tmp12_ = NULL;
		gchar* _tmp13_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp10_ = relay_get_asset_file (MAIN_WINDOW_UI_FILE_SETTINGS);
		_tmp11_ = _tmp10_;
		_tmp12_ = g_strconcat ("Unable to load UI file ", _tmp11_, NULL);
		_tmp13_ = _tmp12_;
		g_error ("settings.vala:50: %s", _tmp13_);
		_g_free0 (_tmp13_);
		_g_free0 (_tmp11_);
		_g_error_free0 (e);
	}
	__finally16:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (builder);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	_tmp14_ = builder;
	_tmp15_ = gtk_builder_get_object (_tmp14_, "window");
	_tmp16_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp15_, gtk_window_get_type ()) ? ((GtkWindow*) _tmp15_) : NULL);
	_g_object_unref0 (self->priv->window);
	self->priv->window = _tmp16_;
	{
		const gchar** name_collection = NULL;
		gint name_collection_length1 = 0;
		gint _name_collection_size_ = 0;
		gint name_it = 0;
		name_collection = SETTINGS_switch_names;
		name_collection_length1 = G_N_ELEMENTS (SETTINGS_switch_names);
		for (name_it = 0; name_it < G_N_ELEMENTS (SETTINGS_switch_names); name_it = name_it + 1) {
			gchar* _tmp17_ = NULL;
			gchar* name = NULL;
			_tmp17_ = g_strdup (name_collection[name_it]);
			name = _tmp17_;
			{
				GtkSwitch* switches = NULL;
				GtkBuilder* _tmp18_ = NULL;
				const gchar* _tmp19_ = NULL;
				GObject* _tmp20_ = NULL;
				GtkSwitch* _tmp21_ = NULL;
				GSettings* _tmp22_ = NULL;
				const gchar* _tmp23_ = NULL;
				gchar* _tmp24_ = NULL;
				gchar* _tmp25_ = NULL;
				GtkSwitch* _tmp26_ = NULL;
				_tmp18_ = builder;
				_tmp19_ = name;
				_tmp20_ = gtk_builder_get_object (_tmp18_, _tmp19_);
				_tmp21_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp20_, gtk_switch_get_type ()) ? ((GtkSwitch*) _tmp20_) : NULL);
				switches = _tmp21_;
				_tmp22_ = self->priv->settings;
				_tmp23_ = name;
				_tmp24_ = string_replace (_tmp23_, "_", "-");
				_tmp25_ = _tmp24_;
				_tmp26_ = switches;
				g_settings_bind (_tmp22_, _tmp25_, (GObject*) _tmp26_, "active", G_SETTINGS_BIND_DEFAULT);
				_g_free0 (_tmp25_);
				_g_object_unref0 (switches);
				_g_free0 (name);
			}
		}
	}
	_tmp27_ = builder;
	_tmp28_ = gtk_builder_get_object (_tmp27_, "show_tabs");
	_tmp29_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp28_, gtk_switch_get_type ()) ? ((GtkSwitch*) _tmp28_) : NULL);
	show_tabs = _tmp29_;
	_tmp30_ = show_tabs;
	g_signal_connect_object (_tmp30_, "state-set", (GCallback) ___lambda11__gtk_switch_state_set, self, 0);
	{
		const gchar** type_collection = NULL;
		gint type_collection_length1 = 0;
		gint _type_collection_size_ = 0;
		gint type_it = 0;
		type_collection = SETTINGS_color_names;
		type_collection_length1 = G_N_ELEMENTS (SETTINGS_color_names);
		for (type_it = 0; type_it < G_N_ELEMENTS (SETTINGS_color_names); type_it = type_it + 1) {
			gchar* _tmp31_ = NULL;
			gchar* type = NULL;
			_tmp31_ = g_strdup (type_collection[type_it]);
			type = _tmp31_;
			{
				Block21Data* _data21_;
				GtkBuilder* _tmp32_ = NULL;
				const gchar* _tmp33_ = NULL;
				GObject* _tmp34_ = NULL;
				GtkEntry* _tmp35_ = NULL;
				GSettings* _tmp36_ = NULL;
				const gchar* _tmp37_ = NULL;
				GtkEntry* _tmp38_ = NULL;
				GtkEntry* _tmp39_ = NULL;
				GtkEntry* _tmp40_ = NULL;
				GtkButton* reset = NULL;
				GtkBuilder* _tmp41_ = NULL;
				const gchar* _tmp42_ = NULL;
				gchar* _tmp43_ = NULL;
				gchar* _tmp44_ = NULL;
				GObject* _tmp45_ = NULL;
				GtkButton* _tmp46_ = NULL;
				GtkButton* _tmp47_ = NULL;
				GtkButton* _tmp48_ = NULL;
				gchar* change_back = NULL;
				GtkEntry* _tmp49_ = NULL;
				const gchar* _tmp50_ = NULL;
				const gchar* _tmp51_ = NULL;
				gchar* _tmp52_ = NULL;
				GtkEntry* _tmp53_ = NULL;
				GtkEntry* _tmp54_ = NULL;
				const gchar* _tmp55_ = NULL;
				PangoFontDescription* bold = NULL;
				PangoFontDescription* _tmp56_ = NULL;
				PangoFontDescription* _tmp57_ = NULL;
				GtkEntry* _tmp58_ = NULL;
				PangoFontDescription* _tmp59_ = NULL;
				_data21_ = g_slice_new0 (Block21Data);
				_data21_->_ref_count_ = 1;
				_data21_->self = g_object_ref (self);
				_data21_->type = type;
				_tmp32_ = builder;
				_tmp33_ = _data21_->type;
				_tmp34_ = gtk_builder_get_object (_tmp32_, _tmp33_);
				_tmp35_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp34_, gtk_entry_get_type ()) ? ((GtkEntry*) _tmp34_) : NULL);
				_data21_->colors = _tmp35_;
				_tmp36_ = self->priv->settings;
				_tmp37_ = _data21_->type;
				_tmp38_ = _data21_->colors;
				g_settings_bind (_tmp36_, _tmp37_, (GObject*) _tmp38_, "text", G_SETTINGS_BIND_DEFAULT);
				_tmp39_ = _data21_->colors;
				g_signal_connect_data ((GtkWidget*) _tmp39_, "button-press-event", (GCallback) _____lambda12__gtk_widget_button_press_event, block21_data_ref (_data21_), (GClosureNotify) block21_data_unref, 0);
				_tmp40_ = _data21_->colors;
				g_signal_connect_data ((GtkEditable*) _tmp40_, "changed", (GCallback) _____lambda14__gtk_editable_changed, block21_data_ref (_data21_), (GClosureNotify) block21_data_unref, 0);
				_tmp41_ = builder;
				_tmp42_ = _data21_->type;
				_tmp43_ = g_strconcat (_tmp42_, "-reset", NULL);
				_tmp44_ = _tmp43_;
				_tmp45_ = gtk_builder_get_object (_tmp41_, _tmp44_);
				_tmp46_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp45_, gtk_button_get_type ()) ? ((GtkButton*) _tmp45_) : NULL);
				_tmp47_ = _tmp46_;
				_g_free0 (_tmp44_);
				reset = _tmp47_;
				_tmp48_ = reset;
				g_signal_connect_data ((GtkWidget*) _tmp48_, "button-release-event", (GCallback) _____lambda15__gtk_widget_button_release_event, block21_data_ref (_data21_), (GClosureNotify) block21_data_unref, 0);
				_tmp49_ = _data21_->colors;
				_tmp50_ = gtk_entry_get_text (_tmp49_);
				_tmp51_ = _tmp50_;
				_tmp52_ = g_strdup (_tmp51_);
				change_back = _tmp52_;
				_tmp53_ = _data21_->colors;
				gtk_entry_set_text (_tmp53_, "");
				_tmp54_ = _data21_->colors;
				_tmp55_ = change_back;
				gtk_entry_set_text (_tmp54_, _tmp55_);
				_tmp56_ = pango_font_description_new ();
				bold = _tmp56_;
				_tmp57_ = bold;
				pango_font_description_set_weight (_tmp57_, PANGO_WEIGHT_BOLD);
				_tmp58_ = _data21_->colors;
				_tmp59_ = bold;
				gtk_widget_override_font ((GtkWidget*) _tmp58_, _tmp59_);
				__vala_PangoFontDescription_free0 (bold);
				_g_free0 (change_back);
				_g_object_unref0 (reset);
				block21_data_unref (_data21_);
				_data21_ = NULL;
			}
		}
	}
	_tmp60_ = builder;
	_tmp61_ = gtk_builder_get_object (_tmp60_, "close");
	_tmp62_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp61_, gtk_button_get_type ()) ? ((GtkButton*) _tmp61_) : NULL);
	close = _tmp62_;
	_tmp63_ = close;
	g_signal_connect_object ((GtkWidget*) _tmp63_, "button-release-event", (GCallback) ___lambda16__gtk_widget_button_release_event, self, 0);
	_tmp64_ = self->priv->window;
	gtk_widget_show_all ((GtkWidget*) _tmp64_);
	result = TRUE;
	_g_object_unref0 (close);
	_g_object_unref0 (show_tabs);
	_g_object_unref0 (builder);
	return result;
}


gchar* settings_get_color (Settings* self, const gchar* color) {
	gchar* result = NULL;
	gchar* val = NULL;
	GSettings* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (color != NULL, NULL);
	_tmp0_ = self->priv->settings;
	_tmp1_ = color;
	_tmp2_ = g_settings_get_string (_tmp0_, _tmp1_);
	val = _tmp2_;
	_tmp4_ = val;
	if (g_strcmp0 (_tmp4_, "default") == 0) {
		GeeHashMap* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		gpointer _tmp7_ = NULL;
		_tmp5_ = self->priv->colors_defaults;
		_tmp6_ = color;
		_tmp7_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp5_, _tmp6_);
		_g_free0 (_tmp3_);
		_tmp3_ = (gchar*) _tmp7_;
	} else {
		const gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		_tmp8_ = val;
		_tmp9_ = g_strdup (_tmp8_);
		_g_free0 (_tmp3_);
		_tmp3_ = _tmp9_;
	}
	result = _tmp3_;
	_g_free0 (val);
	return result;
}


gboolean settings_get_bool (Settings* self, const gchar* name) {
	gboolean result = FALSE;
	GSettings* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (name != NULL, FALSE);
	_tmp0_ = self->priv->settings;
	_tmp1_ = name;
	_tmp2_ = string_replace (_tmp1_, "_", "-");
	_tmp3_ = _tmp2_;
	_tmp4_ = g_settings_get_boolean (_tmp0_, _tmp3_);
	_tmp5_ = _tmp4_;
	_g_free0 (_tmp3_);
	result = _tmp5_;
	return result;
}


gchar* settings_RGBA_to_hex (GdkRGBA* rgba) {
	gchar* result = NULL;
	gchar* s = NULL;
	GdkRGBA _tmp0_ = {0};
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	GdkRGBA _tmp3_ = {0};
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	GdkRGBA _tmp6_ = {0};
	gdouble _tmp7_ = 0.0;
	gdouble _tmp8_ = 0.0;
	GdkRGBA _tmp9_ = {0};
	gdouble _tmp10_ = 0.0;
	gdouble _tmp11_ = 0.0;
	gchar* _tmp12_ = NULL;
	gchar* _tmp13_ = NULL;
	gchar* _tmp14_ = NULL;
	gchar* _tmp15_ = NULL;
	g_return_val_if_fail (rgba != NULL, NULL);
	_tmp0_ = *rgba;
	_tmp1_ = _tmp0_.red;
	_tmp2_ = round (_tmp1_ * 255);
	_tmp3_ = *rgba;
	_tmp4_ = _tmp3_.green;
	_tmp5_ = round (_tmp4_ * 255);
	_tmp6_ = *rgba;
	_tmp7_ = _tmp6_.blue;
	_tmp8_ = round (_tmp7_ * 255);
	_tmp9_ = *rgba;
	_tmp10_ = _tmp9_.alpha;
	_tmp11_ = round (_tmp10_ * 255);
	_tmp12_ = g_strdup_printf ("#%02x%02x%02x%02x", (guint) _tmp2_, (guint) _tmp5_, (guint) _tmp8_, (guint) _tmp11_);
	_tmp13_ = _tmp12_;
	_tmp14_ = g_utf8_strup (_tmp13_, (gssize) -1);
	_tmp15_ = _tmp14_;
	_g_free0 (_tmp13_);
	s = _tmp15_;
	result = s;
	return result;
}


void settings_set_colors_defaults (Settings* self) {
	const gchar* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	GeeHashMap* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	GeeHashMap* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	gboolean _tmp7_ = FALSE;
	GeeHashMap* _tmp8_ = NULL;
	const gchar* _tmp9_ = NULL;
	gboolean _tmp10_ = FALSE;
	GeeHashMap* _tmp11_ = NULL;
	const gchar* _tmp12_ = NULL;
	gboolean _tmp13_ = FALSE;
	GeeHashMap* _tmp14_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp1_ = relay_is_light_theme;
	if (_tmp1_) {
		_tmp0_ = "#3B1C73";
	} else {
		_tmp0_ = "#AE81FF";
	}
	_tmp2_ = self->priv->colors_defaults;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp2_, "user-self-color", _tmp0_);
	_tmp4_ = relay_is_light_theme;
	if (_tmp4_) {
		_tmp3_ = "#1D6A77";
	} else {
		_tmp3_ = "#4EC9DE";
	}
	_tmp5_ = self->priv->colors_defaults;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp5_, "user-other-color", _tmp3_);
	_tmp7_ = relay_is_light_theme;
	if (_tmp7_) {
		_tmp6_ = "#505050";
	} else {
		_tmp6_ = "#F8F8F2";
	}
	_tmp8_ = self->priv->colors_defaults;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp8_, "message-color", _tmp6_);
	_tmp10_ = relay_is_light_theme;
	if (_tmp10_) {
		_tmp9_ = "#0000FF";
	} else {
		_tmp9_ = "#3D81C4";
	}
	_tmp11_ = self->priv->colors_defaults;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp11_, "link-color", _tmp9_);
	_tmp13_ = relay_is_light_theme;
	if (_tmp13_) {
		_tmp12_ = "#181818";
	} else {
		_tmp12_ = "#D5D5D5";
	}
	_tmp14_ = self->priv->colors_defaults;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp14_, "timestamp-color", _tmp12_);
}


Settings* settings_construct (GType object_type) {
	Settings * self = NULL;
	self = (Settings*) g_object_new (object_type, NULL);
	return self;
}


Settings* settings_new (void) {
	return settings_construct (TYPE_SETTINGS);
}


static GObject * settings_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	Settings * self;
	GSettings* _tmp0_ = NULL;
	parent_class = G_OBJECT_CLASS (settings_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SETTINGS, Settings);
	_tmp0_ = g_settings_new ("org.agronick.relay");
	_g_object_unref0 (self->priv->settings);
	self->priv->settings = _tmp0_;
	settings_set_colors_defaults (self);
	return obj;
}


static void settings_class_init (SettingsClass * klass) {
	settings_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SettingsPrivate));
	G_OBJECT_CLASS (klass)->constructor = settings_constructor;
	G_OBJECT_CLASS (klass)->finalize = settings_finalize;
	g_signal_new ("changed_color", TYPE_SETTINGS, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("show_hide_tabs", TYPE_SETTINGS, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__BOOLEAN, G_TYPE_NONE, 1, G_TYPE_BOOLEAN);
}


static void settings_instance_init (Settings * self) {
	GeeHashMap* _tmp0_ = NULL;
	self->priv = SETTINGS_GET_PRIVATE (self);
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	self->priv->colors_defaults = _tmp0_;
	self->priv->window = NULL;
}


static void settings_finalize (GObject* obj) {
	Settings * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SETTINGS, Settings);
	_g_object_unref0 (self->priv->colors_defaults);
	_g_object_unref0 (self->priv->settings);
	_g_object_unref0 (self->priv->window);
	G_OBJECT_CLASS (settings_parent_class)->finalize (obj);
}


GType settings_get_type (void) {
	static volatile gsize settings_type_id__volatile = 0;
	if (g_once_init_enter (&settings_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SettingsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) settings_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Settings), 0, (GInstanceInitFunc) settings_instance_init, NULL };
		GType settings_type_id;
		settings_type_id = g_type_register_static (G_TYPE_OBJECT, "Settings", &g_define_type_info, 0);
		g_once_init_leave (&settings_type_id__volatile, settings_type_id);
	}
	return settings_type_id__volatile;
}



