/* connection.c generated by valac 0.34.4, the Vala compiler
 * generated from connection.vala, do not modify */

/* -*- Mode: vala; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*-  */
/*
 * connection.vala
 * Copyright (C) 2015 Kyle Agronick <stack@kyle-ele>
 *
 * KyRC is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * KyRC is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <granite.h>
#include <glib/gi18n-lib.h>
#include <gdk/gdk.h>
#include <gtk/gtk.h>


#define TYPE_CONNECTION (connection_get_type ())
#define CONNECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONNECTION, Connection))
#define CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONNECTION, ConnectionClass))
#define IS_CONNECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONNECTION))
#define IS_CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONNECTION))
#define CONNECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONNECTION, ConnectionClass))

typedef struct _Connection Connection;
typedef struct _ConnectionClass ConnectionClass;
typedef struct _ConnectionPrivate ConnectionPrivate;

#define TYPE_CHANNEL_TAB (channel_tab_get_type ())
#define CHANNEL_TAB(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CHANNEL_TAB, ChannelTab))
#define CHANNEL_TAB_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CHANNEL_TAB, ChannelTabClass))
#define IS_CHANNEL_TAB(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CHANNEL_TAB))
#define IS_CHANNEL_TAB_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CHANNEL_TAB))
#define CHANNEL_TAB_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CHANNEL_TAB, ChannelTabClass))

typedef struct _ChannelTab ChannelTab;
typedef struct _ChannelTabClass ChannelTabClass;

#define SQL_CLIENT_TYPE_SERVER (sql_client_server_get_type ())
#define SQL_CLIENT_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SQL_CLIENT_TYPE_SERVER, SqlClientServer))
#define SQL_CLIENT_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SQL_CLIENT_TYPE_SERVER, SqlClientServerClass))
#define SQL_CLIENT_IS_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SQL_CLIENT_TYPE_SERVER))
#define SQL_CLIENT_IS_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SQL_CLIENT_TYPE_SERVER))
#define SQL_CLIENT_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SQL_CLIENT_TYPE_SERVER, SqlClientServerClass))

typedef struct _SqlClientServer SqlClientServer;
typedef struct _SqlClientServerClass SqlClientServerClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _sql_client_server_unref0(var) ((var == NULL) ? NULL : (var = (sql_client_server_unref (var), NULL)))
typedef struct _SqlClientServerPrivate SqlClientServerPrivate;

#define SQL_CLIENT_TYPE_CHANNEL (sql_client_channel_get_type ())
#define SQL_CLIENT_CHANNEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SQL_CLIENT_TYPE_CHANNEL, SqlClientChannel))
#define SQL_CLIENT_CHANNEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SQL_CLIENT_TYPE_CHANNEL, SqlClientChannelClass))
#define SQL_CLIENT_IS_CHANNEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SQL_CLIENT_TYPE_CHANNEL))
#define SQL_CLIENT_IS_CHANNEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SQL_CLIENT_TYPE_CHANNEL))
#define SQL_CLIENT_CHANNEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SQL_CLIENT_TYPE_CHANNEL, SqlClientChannelClass))

typedef struct _SqlClientChannel SqlClientChannel;
typedef struct _SqlClientChannelClass SqlClientChannelClass;
typedef struct _ChannelTabPrivate ChannelTabPrivate;
#define _g_thread_unref0(var) ((var == NULL) ? NULL : (var = (g_thread_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _Block16Data Block16Data;

#define TYPE_MESSAGE (message_get_type ())
#define MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MESSAGE, Message))
#define MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MESSAGE, MessageClass))
#define IS_MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MESSAGE))
#define IS_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MESSAGE))
#define MESSAGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MESSAGE, MessageClass))

typedef struct _Message Message;
typedef struct _MessageClass MessageClass;
typedef struct _MessagePrivate MessagePrivate;
typedef struct _Block17Data Block17Data;
typedef struct _Block18Data Block18Data;

struct _Connection {
	GObject parent_instance;
	ConnectionPrivate * priv;
	ChannelTab* server_tab;
	GeeHashMap* channel_tabs;
	GeeLinkedList* channel_autoconnect;
	gboolean exit;
	gboolean error_state;
	gboolean autoconnect_ran;
	SqlClientServer* server;
};

struct _ConnectionClass {
	GObjectClass parent_class;
};

struct _ConnectionPrivate {
	GDataInputStream* input_stream;
	GDataOutputStream* output_stream;
};

struct _SqlClientServer {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SqlClientServerPrivate * priv;
	gint id;
	gchar* host;
	gint port;
	gchar* nickname;
	gchar* realname;
	gchar* username;
	gchar* password;
	gchar* on_connect;
	gboolean encryption;
	gboolean autoconnect;
	gboolean validate_server;
	gchar* connect_cmds;
	GeeLinkedList* channels;
};

struct _SqlClientServerClass {
	GTypeClass parent_class;
	void (*finalize) (SqlClientServer *self);
};

struct _ChannelTab {
	GObject parent_instance;
	ChannelTabPrivate * priv;
	GraniteWidgetsTab* tab;
	gboolean is_server_tab;
	gboolean has_subject;
	gchar* channel_subject;
	gboolean is_locked;
	GeeLinkedList* users;
	GeeLinkedList* ops;
	GeeLinkedList* half_ops;
	GeeLinkedList* owners;
	GeeLinkedList* blocked_users;
	gint message_count;
	gchar* channel_url;
	gboolean needs_spacer;
};

struct _ChannelTabClass {
	GObjectClass parent_class;
};

struct _Block16Data {
	int _ref_count_;
	Connection* self;
	GError* e;
};

struct _Message {
	GObject parent_instance;
	MessagePrivate * priv;
	gchar* user_name;
	gboolean internal;
	gboolean usr_private_message;
};

struct _MessageClass {
	GObjectClass parent_class;
};

struct _Block17Data {
	int _ref_count_;
	Connection* self;
	gchar* message;
};

struct _Block18Data {
	int _ref_count_;
	Block17Data * _data17_;
	GtkDialog* dialog;
	GtkEntry* server_name;
};


static gpointer connection_parent_class = NULL;
extern GtkWindow* main_window_window;

GType connection_get_type (void) G_GNUC_CONST;
GType channel_tab_get_type (void) G_GNUC_CONST;
gpointer sql_client_server_ref (gpointer instance);
void sql_client_server_unref (gpointer instance);
GParamSpec* sql_client_param_spec_server (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void sql_client_value_set_server (GValue* value, gpointer v_object);
void sql_client_value_take_server (GValue* value, gpointer v_object);
gpointer sql_client_value_get_server (const GValue* value);
GType sql_client_server_get_type (void) G_GNUC_CONST;
#define CONNECTION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_CONNECTION, ConnectionPrivate))
enum  {
	CONNECTION_DUMMY_PROPERTY
};
#define CONNECTION_DEFAULT_PORT ((guint16) 6667)
gboolean connection_connect_to_server (Connection* self, SqlClientServer* _server);
ChannelTab* connection_add_channel_tab (Connection* self, const gchar* _name, gboolean primsg);
gpointer sql_client_channel_ref (gpointer instance);
void sql_client_channel_unref (gpointer instance);
GParamSpec* sql_client_param_spec_channel (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void sql_client_value_set_channel (GValue* value, gpointer v_object);
void sql_client_value_take_channel (GValue* value, gpointer v_object);
gpointer sql_client_value_get_channel (const GValue* value);
GType sql_client_channel_get_type (void) G_GNUC_CONST;
static gint connection_do_connect (Connection* self);
static gpointer _connection_do_connect_gthread_func (gpointer self);
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
void connection_do_register (Connection* self);
static void connection_handle_input (Connection* self, const gchar* msg);
static Block16Data* block16_data_ref (Block16Data* _data16_);
static void block16_data_unref (void * _userdata_);
static gboolean ___lambda24_ (Block16Data* _data16_);
void relay_show_error_window (const gchar* error_msg);
void connection_turn_off_icon (Connection* self, const gchar* channel);
static gboolean ____lambda24__gsource_func (gpointer self);
ChannelTab* channel_tab_new (Connection* param_server);
ChannelTab* channel_tab_construct (GType object_type, Connection* param_server);
static ChannelTab* connection_find_channel_tab (Connection* self, const gchar* name);
void connection_stop (Connection* self);
GType message_get_type (void) G_GNUC_CONST;
Message* message_new (const gchar* _message);
Message* message_construct (GType object_type, const gchar* _message);
const gchar* message_get_command (Message* self);
#define IRC_PRIVATE_MESSAGE "PRIVMSG"
#define IRC_RPL_TOPIC "332"
#define IRC_RPL_CHANNEL_URL "328"
#define IRC_RPL_LUSERCLIENT "251"
#define IRC_RPL_MOTD "372"
#define IRC_RPL_MOTDSTART "375"
#define IRC_RPL_YOURHOST "002"
#define IRC_RPL_LUSEROP "252"
#define IRC_RPL_LUSERUNKNOWN "253"
#define IRC_RPL_LUSERCHANNELS "254"
#define IRC_RPL_UMODEIS "221"
#define IRC_RPL_SERVLIST "234"
#define IRC_RPL_ENDOFSTATS "219"
#define IRC_RPL_STATSLINKINFO "211"
#define IRC_RPL_CREATED "003"
#define IRC_RPL_LUSERME "255"
#define IRC_RPL_WELCOME "001"
#define IRC_RPL_NAMREPLY "353"
#define IRC_QUIT_MSG "QUIT"
#define IRC_PART_MSG "PART"
#define IRC_USER_NAME_CHANGED "NICK"
#define IRC_JOIN_MSG "JOIN"
#define IRC_RPL_ENDOFNAMES "366"
#define IRC_ERR_NICKNAMEINUSE "433"
#define IRC_ERR_NONICKNAMEGIVEN "431"
#define IRC_ERR_LINKCHANNEL "470"
#define IRC_ERR_NOSUCHNICK "401"
#define IRC_ERR_NOSUCHCHANNEL "403"
#define IRC_ERR_WASNOSUCHNICK "406"
#define IRC_ERR_UNKNOWNCOMMAND "421"
#define IRC_ERR_NOMOTD "422"
#define IRC_ERR_USERNOTINCHANNEL "441"
#define IRC_ERR_NOTONCHANNEL "442"
#define IRC_ERR_NOTREGISTERED "451"
#define IRC_ERR_NEEDMOREPARAMS "461"
#define IRC_ERR_UNKNOWNMODE "472"
#define IRC_ERR_ALREADYONCHANNEL "479"
#define IRC_ERR_CHANOPRIVSNEEDED "482"
#define IRC_ERR_NONONREG "486"
static void connection_handle_ping (Connection* self, Message** msg);
gchar** message_get_parameters (Message* self, int* result_length1);
void channel_tab_set_topic (ChannelTab* self, const gchar* subject, gboolean append);
gchar* message_get_msg_txt (Message* self);
const gchar* message_get_message (Message* self);
void channel_tab_display_message (ChannelTab* self, Message* message);
void connection_do_autoconnect (Connection* self);
void connection_run_on_connect_cmds (Connection* self);
void channel_tab_add_users_message (ChannelTab* self, Message* message);
void channel_tab_user_leave_channel (ChannelTab* self, const gchar* _name, const gchar* msg);
void channel_tab_user_name_change (ChannelTab* self, const gchar* _old_name, const gchar* _new_name);
void channel_tab_user_join_channel (ChannelTab* self, const gchar* name);
void channel_tab_sort_names (ChannelTab* self);
void connection_name_in_use (Connection* self, const gchar* message);
void message_set_command (Message* self, const gchar* value);
void connection_send_output (Connection* self, const gchar* output);
void connection_join (Connection* self, const gchar* channel);
static gboolean __lambda20_ (Connection* self);
static gboolean ___lambda20__gsource_func (gpointer self);
void channel_tab_send_text_out (ChannelTab* self, const gchar* message);
static Block17Data* block17_data_ref (Block17Data* _data17_);
static void block17_data_unref (void * _userdata_);
static gboolean __lambda21_ (Block17Data* _data17_);
static Block18Data* block18_data_ref (Block18Data* _data18_);
static void block18_data_unref (void * _userdata_);
static void __lambda22_ (Block18Data* _data18_);
static void ___lambda22__gtk_entry_activate (GtkEntry* _sender, gpointer self);
static void __lambda23_ (Block18Data* _data18_, gint id);
static void ___lambda23__gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self);
static gboolean ___lambda21__gsource_func (gpointer self);
gboolean connection_is_stream_out (Connection* self, GDataOutputStream* output);
gboolean connection_is_stream_in (Connection* self, GDataInputStream* input);
void connection_do_exit (Connection* self);
Connection* connection_new (void);
Connection* connection_construct (GType object_type);
static void g_cclosure_user_marshal_VOID__OBJECT_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void g_cclosure_user_marshal_VOID__OBJECT_OBJECT_BOOLEAN (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void g_cclosure_user_marshal_VOID__STRING_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void connection_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static gpointer _sql_client_server_ref0 (gpointer self) {
	return self ? sql_client_server_ref (self) : NULL;
}


static gpointer _connection_do_connect_gthread_func (gpointer self) {
	gpointer result;
	result = (gpointer) ((gintptr) connection_do_connect ((Connection*) self));
	g_object_unref (self);
	return result;
}


gboolean connection_connect_to_server (Connection* self, SqlClientServer* _server) {
	gboolean result = FALSE;
	SqlClientServer* _tmp0_ = NULL;
	SqlClientServer* _tmp1_ = NULL;
	SqlClientServer* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	ChannelTab* _tmp4_ = NULL;
	ChannelTab* _tmp5_ = NULL;
	SqlClientServer* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	GThread* _tmp10_ = NULL;
	GThread* _tmp11_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (_server != NULL, FALSE);
	_tmp0_ = _server;
	_tmp1_ = _sql_client_server_ref0 (_tmp0_);
	_sql_client_server_unref0 (self->server);
	self->server = _tmp1_;
	_tmp2_ = self->server;
	_tmp3_ = _tmp2_->host;
	_tmp4_ = connection_add_channel_tab (self, _tmp3_, FALSE);
	_g_object_unref0 (self->server_tab);
	self->server_tab = _tmp4_;
	_tmp5_ = self->server_tab;
	_tmp5_->is_server_tab = TRUE;
	_tmp6_ = self->server;
	_tmp7_ = _tmp6_->host;
	_tmp8_ = g_strconcat ("Connection ", _tmp7_, NULL);
	_tmp9_ = _tmp8_;
	_tmp10_ = g_thread_new (_tmp9_, _connection_do_connect_gthread_func, g_object_ref (self));
	_tmp11_ = _tmp10_;
	_g_thread_unref0 (_tmp11_);
	_g_free0 (_tmp9_);
	result = TRUE;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


static gchar* string_strip (const gchar* self) {
	gchar* result = NULL;
	gchar* _result_ = NULL;
	gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	g_strstrip (_tmp1_);
	result = _result_;
	return result;
}


static Block16Data* block16_data_ref (Block16Data* _data16_) {
	g_atomic_int_inc (&_data16_->_ref_count_);
	return _data16_;
}


static void block16_data_unref (void * _userdata_) {
	Block16Data* _data16_;
	_data16_ = (Block16Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data16_->_ref_count_)) {
		Connection* self;
		self = _data16_->self;
		_g_error_free0 (_data16_->e);
		_g_object_unref0 (self);
		g_slice_free (Block16Data, _data16_);
	}
}


static gboolean ___lambda24_ (Block16Data* _data16_) {
	Connection* self;
	gboolean result = FALSE;
	GError* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	ChannelTab* _tmp2_ = NULL;
	GraniteWidgetsTab* _tmp3_ = NULL;
	self = _data16_->self;
	_tmp0_ = _data16_->e;
	_tmp1_ = _tmp0_->message;
	relay_show_error_window (_tmp1_);
	_tmp2_ = self->server_tab;
	_tmp3_ = _tmp2_->tab;
	granite_widgets_tab_close (_tmp3_);
	{
		GeeLinkedList* _tab_list = NULL;
		GeeLinkedList* _tmp4_ = NULL;
		GeeLinkedList* _tmp5_ = NULL;
		gint _tab_size = 0;
		GeeLinkedList* _tmp6_ = NULL;
		gint _tmp7_ = 0;
		gint _tmp8_ = 0;
		gint _tab_index = 0;
		_tmp4_ = self->channel_autoconnect;
		_tmp5_ = _g_object_ref0 (_tmp4_);
		_tab_list = _tmp5_;
		_tmp6_ = _tab_list;
		_tmp7_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp6_);
		_tmp8_ = _tmp7_;
		_tab_size = _tmp8_;
		_tab_index = -1;
		while (TRUE) {
			gint _tmp9_ = 0;
			gint _tmp10_ = 0;
			gint _tmp11_ = 0;
			gchar* tab = NULL;
			GeeLinkedList* _tmp12_ = NULL;
			gint _tmp13_ = 0;
			gpointer _tmp14_ = NULL;
			const gchar* _tmp15_ = NULL;
			_tmp9_ = _tab_index;
			_tab_index = _tmp9_ + 1;
			_tmp10_ = _tab_index;
			_tmp11_ = _tab_size;
			if (!(_tmp10_ < _tmp11_)) {
				break;
			}
			_tmp12_ = _tab_list;
			_tmp13_ = _tab_index;
			_tmp14_ = gee_abstract_list_get ((GeeAbstractList*) _tmp12_, _tmp13_);
			tab = (gchar*) _tmp14_;
			_tmp15_ = tab;
			connection_turn_off_icon (self, _tmp15_);
			_g_free0 (tab);
		}
		_g_object_unref0 (_tab_list);
	}
	result = FALSE;
	return result;
}


static gboolean ____lambda24__gsource_func (gpointer self) {
	gboolean result;
	result = ___lambda24_ (self);
	return result;
}


static gint connection_do_connect (Connection* self) {
	gint result = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	{
		GResolver* resolver = NULL;
		GResolver* _tmp0_ = NULL;
		GList* addresses = NULL;
		GResolver* _tmp1_ = NULL;
		SqlClientServer* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		GList* _tmp4_ = NULL;
		GInetAddress* address = NULL;
		GList* _tmp5_ = NULL;
		gconstpointer _tmp6_ = NULL;
		GInetAddress* _tmp7_ = NULL;
		GSocketClient* client = NULL;
		GSocketClient* _tmp8_ = NULL;
		GSocketClient* _tmp9_ = NULL;
		SqlClientServer* _tmp10_ = NULL;
		gboolean _tmp11_ = FALSE;
		GSocketClient* _tmp12_ = NULL;
		GSocketConnection* conn = NULL;
		GSocketClient* _tmp13_ = NULL;
		GInetAddress* _tmp14_ = NULL;
		SqlClientServer* _tmp15_ = NULL;
		gint _tmp16_ = 0;
		GInetSocketAddress* _tmp17_ = NULL;
		GInetSocketAddress* _tmp18_ = NULL;
		GSocketConnection* _tmp19_ = NULL;
		GSocketConnection* _tmp20_ = NULL;
		GSocketConnection* _tmp21_ = NULL;
		GInputStream* _tmp22_ = NULL;
		GInputStream* _tmp23_ = NULL;
		GDataInputStream* _tmp24_ = NULL;
		GSocketConnection* _tmp25_ = NULL;
		GOutputStream* _tmp26_ = NULL;
		GOutputStream* _tmp27_ = NULL;
		GDataOutputStream* _tmp28_ = NULL;
		SqlClientServer* _tmp29_ = NULL;
		const gchar* _tmp30_ = NULL;
		gchar* _tmp31_ = NULL;
		gchar* _tmp32_ = NULL;
		gint _tmp33_ = 0;
		gint _tmp34_ = 0;
		gboolean _tmp35_ = FALSE;
		SqlClientServer* _tmp39_ = NULL;
		const gchar* _tmp40_ = NULL;
		gchar* _tmp41_ = NULL;
		gchar* _tmp42_ = NULL;
		gint _tmp43_ = 0;
		gint _tmp44_ = 0;
		gboolean _tmp45_ = FALSE;
		SqlClientServer* _tmp49_ = NULL;
		const gchar* _tmp50_ = NULL;
		gchar* _tmp51_ = NULL;
		gchar* _tmp52_ = NULL;
		gint _tmp53_ = 0;
		gint _tmp54_ = 0;
		gboolean _tmp55_ = FALSE;
		gchar* line = NULL;
		gchar* _tmp60_ = NULL;
		_tmp0_ = g_resolver_get_default ();
		resolver = _tmp0_;
		_tmp1_ = resolver;
		_tmp2_ = self->server;
		_tmp3_ = _tmp2_->host;
		_tmp4_ = g_resolver_lookup_by_name (_tmp1_, _tmp3_, NULL, &_inner_error_);
		addresses = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (resolver);
			goto __catch9_g_error;
		}
		_tmp5_ = addresses;
		_tmp6_ = g_list_nth_data (_tmp5_, (guint) 0);
		_tmp7_ = _g_object_ref0 ((GInetAddress*) _tmp6_);
		address = _tmp7_;
		_tmp8_ = g_socket_client_new ();
		client = _tmp8_;
		_tmp9_ = client;
		_tmp10_ = self->server;
		_tmp11_ = _tmp10_->encryption;
		g_socket_client_set_tls (_tmp9_, _tmp11_);
		_tmp12_ = client;
		g_socket_client_set_tls_validation_flags (_tmp12_, G_TLS_CERTIFICATE_GENERIC_ERROR);
		_tmp13_ = client;
		_tmp14_ = address;
		_tmp15_ = self->server;
		_tmp16_ = _tmp15_->port;
		_tmp17_ = (GInetSocketAddress*) g_inet_socket_address_new (_tmp14_, (guint16) _tmp16_);
		_tmp18_ = _tmp17_;
		_tmp19_ = g_socket_client_connect (_tmp13_, (GSocketConnectable*) _tmp18_, NULL, &_inner_error_);
		_tmp20_ = _tmp19_;
		_g_object_unref0 (_tmp18_);
		conn = _tmp20_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (client);
			_g_object_unref0 (address);
			__g_list_free__g_object_unref0_0 (addresses);
			_g_object_unref0 (resolver);
			goto __catch9_g_error;
		}
		_tmp21_ = conn;
		_tmp22_ = g_io_stream_get_input_stream ((GIOStream*) _tmp21_);
		_tmp23_ = _tmp22_;
		_tmp24_ = g_data_input_stream_new (_tmp23_);
		_g_object_unref0 (self->priv->input_stream);
		self->priv->input_stream = _tmp24_;
		_tmp25_ = conn;
		_tmp26_ = g_io_stream_get_output_stream ((GIOStream*) _tmp25_);
		_tmp27_ = _tmp26_;
		_tmp28_ = g_data_output_stream_new (_tmp27_);
		_g_object_unref0 (self->priv->output_stream);
		self->priv->output_stream = _tmp28_;
		_tmp29_ = self->server;
		_tmp30_ = _tmp29_->username;
		_tmp31_ = string_strip (_tmp30_);
		_tmp32_ = _tmp31_;
		_tmp33_ = strlen (_tmp32_);
		_tmp34_ = _tmp33_;
		_tmp35_ = _tmp34_ == 0;
		_g_free0 (_tmp32_);
		if (_tmp35_) {
			SqlClientServer* _tmp36_ = NULL;
			const gchar* _tmp37_ = NULL;
			gchar* _tmp38_ = NULL;
			_tmp36_ = self->server;
			_tmp37_ = g_get_user_name ();
			_tmp38_ = g_strdup (_tmp37_);
			_g_free0 (_tmp36_->username);
			_tmp36_->username = _tmp38_;
		}
		_tmp39_ = self->server;
		_tmp40_ = _tmp39_->nickname;
		_tmp41_ = string_strip (_tmp40_);
		_tmp42_ = _tmp41_;
		_tmp43_ = strlen (_tmp42_);
		_tmp44_ = _tmp43_;
		_tmp45_ = _tmp44_ == 0;
		_g_free0 (_tmp42_);
		if (_tmp45_) {
			SqlClientServer* _tmp46_ = NULL;
			const gchar* _tmp47_ = NULL;
			gchar* _tmp48_ = NULL;
			_tmp46_ = self->server;
			_tmp47_ = g_get_user_name ();
			_tmp48_ = g_strdup (_tmp47_);
			_g_free0 (_tmp46_->nickname);
			_tmp46_->nickname = _tmp48_;
		}
		_tmp49_ = self->server;
		_tmp50_ = _tmp49_->realname;
		_tmp51_ = string_strip (_tmp50_);
		_tmp52_ = _tmp51_;
		_tmp53_ = strlen (_tmp52_);
		_tmp54_ = _tmp53_;
		_tmp55_ = _tmp54_ == 0;
		_g_free0 (_tmp52_);
		if (_tmp55_) {
			SqlClientServer* _tmp56_ = NULL;
			SqlClientServer* _tmp57_ = NULL;
			const gchar* _tmp58_ = NULL;
			gchar* _tmp59_ = NULL;
			_tmp56_ = self->server;
			_tmp57_ = self->server;
			_tmp58_ = _tmp57_->nickname;
			_tmp59_ = g_strdup (_tmp58_);
			_g_free0 (_tmp56_->realname);
			_tmp56_->realname = _tmp59_;
		}
		connection_do_register (self);
		_tmp60_ = g_strdup ("");
		line = _tmp60_;
		{
			gboolean _tmp61_ = FALSE;
			_tmp61_ = TRUE;
			while (TRUE) {
				gsize size = 0UL;
				if (!_tmp61_) {
					gboolean _tmp62_ = FALSE;
					const gchar* _tmp63_ = NULL;
					_tmp63_ = line;
					if (_tmp63_ != NULL) {
						gboolean _tmp64_ = FALSE;
						_tmp64_ = self->exit;
						_tmp62_ = !_tmp64_;
					} else {
						_tmp62_ = FALSE;
					}
					if (!_tmp62_) {
						break;
					}
				}
				_tmp61_ = FALSE;
				{
					gchar* _tmp65_ = NULL;
					GDataInputStream* _tmp66_ = NULL;
					gsize _tmp67_ = 0UL;
					gchar* _tmp68_ = NULL;
					gchar* _tmp69_ = NULL;
					const gchar* _tmp70_ = NULL;
					gchar* _tmp71_ = NULL;
					gchar* _tmp72_ = NULL;
					const gchar* _tmp73_ = NULL;
					_tmp66_ = self->priv->input_stream;
					_tmp68_ = g_data_input_stream_read_line (_tmp66_, &_tmp67_, NULL, &_inner_error_);
					size = _tmp67_;
					_tmp65_ = _tmp68_;
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						if (_inner_error_->domain == G_IO_ERROR) {
							goto __catch10_g_io_error;
						}
						_g_free0 (line);
						_g_object_unref0 (conn);
						_g_object_unref0 (client);
						_g_object_unref0 (address);
						__g_list_free__g_object_unref0_0 (addresses);
						_g_object_unref0 (resolver);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return 0;
					}
					_tmp69_ = _tmp65_;
					_tmp65_ = NULL;
					_g_free0 (line);
					line = _tmp69_;
					_tmp70_ = line;
					_tmp71_ = g_strconcat ("Raw input ", _tmp70_, NULL);
					_tmp72_ = _tmp71_;
					g_debug ("connection.vala:82: %s", _tmp72_);
					_g_free0 (_tmp72_);
					_tmp73_ = line;
					connection_handle_input (self, _tmp73_);
					_g_free0 (_tmp65_);
				}
				goto __finally10;
				__catch10_g_io_error:
				{
					GError* e = NULL;
					GError* _tmp74_ = NULL;
					const gchar* _tmp75_ = NULL;
					gchar* _tmp76_ = NULL;
					gchar* _tmp77_ = NULL;
					e = _inner_error_;
					_inner_error_ = NULL;
					self->error_state = TRUE;
					_tmp74_ = e;
					_tmp75_ = _tmp74_->message;
					_tmp76_ = g_strconcat ("IO error while reading ", _tmp75_, NULL);
					_tmp77_ = _tmp76_;
					g_warning ("connection.vala:86: %s", _tmp77_);
					_g_free0 (_tmp77_);
					_g_error_free0 (e);
				}
				__finally10:
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					_g_free0 (line);
					_g_object_unref0 (conn);
					_g_object_unref0 (client);
					_g_object_unref0 (address);
					__g_list_free__g_object_unref0_0 (addresses);
					_g_object_unref0 (resolver);
					goto __catch9_g_error;
				}
			}
		}
		_g_free0 (line);
		_g_object_unref0 (conn);
		_g_object_unref0 (client);
		_g_object_unref0 (address);
		__g_list_free__g_object_unref0_0 (addresses);
		_g_object_unref0 (resolver);
	}
	goto __finally9;
	__catch9_g_error:
	{
		GError* err = NULL;
		Block16Data* _data16_;
		GError* _tmp78_ = NULL;
		GError* _tmp79_ = NULL;
		const gchar* _tmp80_ = NULL;
		gchar* _tmp81_ = NULL;
		gchar* _tmp82_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_data16_ = g_slice_new0 (Block16Data);
		_data16_->_ref_count_ = 1;
		_data16_->self = g_object_ref (self);
		_tmp78_ = err;
		err = NULL;
		_data16_->e = _tmp78_;
		_tmp79_ = _data16_->e;
		_tmp80_ = _tmp79_->message;
		_tmp81_ = g_strconcat ("Could not connect ", _tmp80_, NULL);
		_tmp82_ = _tmp81_;
		g_warning ("connection.vala:91: %s", _tmp82_);
		_g_free0 (_tmp82_);
		self->error_state = TRUE;
		g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ____lambda24__gsource_func, block16_data_ref (_data16_), block16_data_unref);
		result = 0;
		_g_error_free0 (err);
		block16_data_unref (_data16_);
		_data16_ = NULL;
		return result;
	}
	__finally9:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	result = 1;
	return result;
}


ChannelTab* connection_add_channel_tab (Connection* self, const gchar* _name, gboolean primsg) {
	ChannelTab* result = NULL;
	gchar* name = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	const gchar* _tmp4_ = NULL;
	gboolean _tmp9_ = FALSE;
	gboolean _tmp10_ = FALSE;
	const gchar* _tmp11_ = NULL;
	SqlClientServer* _tmp12_ = NULL;
	const gchar* _tmp13_ = NULL;
	GeeHashMap* _tmp22_ = NULL;
	const gchar* _tmp23_ = NULL;
	gboolean _tmp24_ = FALSE;
	ChannelTab* newTab = NULL;
	ChannelTab* _tmp28_ = NULL;
	ChannelTab* _tmp29_ = NULL;
	const gchar* _tmp30_ = NULL;
	GeeHashMap* _tmp31_ = NULL;
	const gchar* _tmp32_ = NULL;
	ChannelTab* _tmp33_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = _name;
	_tmp1_ = g_strdup (_tmp0_);
	name = _tmp1_;
	_tmp4_ = name;
	if (_tmp4_ == NULL) {
		_tmp3_ = TRUE;
	} else {
		const gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		_tmp5_ = name;
		_tmp6_ = string_strip (_tmp5_);
		_tmp7_ = _tmp6_;
		_tmp3_ = g_strcmp0 (_tmp7_, "") == 0;
		_g_free0 (_tmp7_);
	}
	if (_tmp3_) {
		_tmp2_ = TRUE;
	} else {
		SqlClientServer* _tmp8_ = NULL;
		_tmp8_ = self->server;
		_tmp2_ = _tmp8_ == NULL;
	}
	if (_tmp2_) {
		result = NULL;
		_g_free0 (name);
		return result;
	}
	_tmp11_ = name;
	_tmp12_ = self->server;
	_tmp13_ = _tmp12_->username;
	if (g_strcmp0 (_tmp11_, _tmp13_) == 0) {
		_tmp10_ = TRUE;
	} else {
		gboolean _tmp14_ = FALSE;
		const gchar* _tmp15_ = NULL;
		SqlClientServer* _tmp16_ = NULL;
		const gchar* _tmp17_ = NULL;
		_tmp15_ = name;
		_tmp16_ = self->server;
		_tmp17_ = _tmp16_->nickname;
		if (g_strcmp0 (_tmp15_, _tmp17_) == 0) {
			gboolean _tmp18_ = FALSE;
			_tmp18_ = primsg;
			_tmp14_ = !_tmp18_;
		} else {
			_tmp14_ = FALSE;
		}
		_tmp10_ = _tmp14_;
	}
	if (_tmp10_) {
		_tmp9_ = TRUE;
	} else {
		const gchar* _tmp19_ = NULL;
		_tmp19_ = name;
		_tmp9_ = g_strcmp0 (_tmp19_, "IRC") == 0;
	}
	if (_tmp9_) {
		ChannelTab* _tmp20_ = NULL;
		ChannelTab* _tmp21_ = NULL;
		_tmp20_ = self->server_tab;
		_tmp21_ = _g_object_ref0 (_tmp20_);
		result = _tmp21_;
		_g_free0 (name);
		return result;
	}
	_tmp22_ = self->channel_tabs;
	_tmp23_ = name;
	_tmp24_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp22_, _tmp23_);
	if (_tmp24_) {
		GeeHashMap* _tmp25_ = NULL;
		const gchar* _tmp26_ = NULL;
		gpointer _tmp27_ = NULL;
		_tmp25_ = self->channel_tabs;
		_tmp26_ = name;
		_tmp27_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp25_, _tmp26_);
		result = (ChannelTab*) _tmp27_;
		_g_free0 (name);
		return result;
	}
	_tmp28_ = channel_tab_new (self);
	newTab = _tmp28_;
	_tmp29_ = newTab;
	_tmp30_ = name;
	g_signal_emit_by_name (self, "new-tab", _tmp29_, _tmp30_);
	_tmp31_ = self->channel_tabs;
	_tmp32_ = name;
	_tmp33_ = newTab;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp31_, _tmp32_, _tmp33_);
	result = newTab;
	_g_free0 (name);
	return result;
}


static ChannelTab* connection_find_channel_tab (Connection* self, const gchar* name) {
	ChannelTab* result = NULL;
	const gchar* _tmp0_ = NULL;
	ChannelTab* _tmp7_ = NULL;
	ChannelTab* _tmp8_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = name;
	if (_tmp0_ == NULL) {
		result = NULL;
		return result;
	} else {
		GeeHashMap* _tmp1_ = NULL;
		const gchar* _tmp2_ = NULL;
		gboolean _tmp3_ = FALSE;
		_tmp1_ = self->channel_tabs;
		_tmp2_ = name;
		_tmp3_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp1_, _tmp2_);
		if (_tmp3_) {
			GeeHashMap* _tmp4_ = NULL;
			const gchar* _tmp5_ = NULL;
			gpointer _tmp6_ = NULL;
			_tmp4_ = self->channel_tabs;
			_tmp5_ = name;
			_tmp6_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp4_, _tmp5_);
			result = (ChannelTab*) _tmp6_;
			return result;
		}
	}
	_tmp7_ = self->server_tab;
	_tmp8_ = _g_object_ref0 (_tmp7_);
	result = _tmp8_;
	return result;
}


static void connection_handle_input (Connection* self, const gchar* msg) {
	const gchar* _tmp0_ = NULL;
	Message* message = NULL;
	const gchar* _tmp1_ = NULL;
	Message* _tmp2_ = NULL;
	Message* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	GQuark _tmp8_ = 0U;
	static GQuark _tmp7_label0 = 0;
	static GQuark _tmp7_label1 = 0;
	static GQuark _tmp7_label2 = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = msg;
	if (_tmp0_ == NULL) {
		connection_stop (self);
		return;
	}
	_tmp1_ = msg;
	_tmp2_ = message_new (_tmp1_);
	message = _tmp2_;
	_tmp3_ = message;
	_tmp4_ = message_get_command (_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = _tmp5_;
	_tmp8_ = (NULL == _tmp6_) ? 0 : g_quark_from_string (_tmp6_);
	if (_tmp8_ == ((0 != _tmp7_label0) ? _tmp7_label0 : (_tmp7_label0 = g_quark_from_static_string ("PING")))) {
		switch (0) {
			default:
			{
				connection_handle_ping (self, &message);
				_g_object_unref0 (message);
				return;
			}
		}
	} else if (_tmp8_ == ((0 != _tmp7_label1) ? _tmp7_label1 : (_tmp7_label1 = g_quark_from_static_string ("PONG")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp9_ = NULL;
				_tmp9_ = msg;
				g_info ("connection.vala:142: %s", _tmp9_);
				_g_object_unref0 (message);
				return;
			}
		}
	} else if (_tmp8_ == g_quark_from_string (IRC_PRIVATE_MESSAGE)) {
		switch (0) {
			default:
			{
				ChannelTab* tab = NULL;
				Message* _tmp10_ = NULL;
				gchar** _tmp11_ = NULL;
				gint _tmp11__length1 = 0;
				gchar** _tmp12_ = NULL;
				gint _tmp12__length1 = 0;
				const gchar* _tmp13_ = NULL;
				ChannelTab* _tmp14_ = NULL;
				gboolean _tmp15_ = FALSE;
				ChannelTab* _tmp16_ = NULL;
				ChannelTab* _tmp17_ = NULL;
				ChannelTab* _tmp27_ = NULL;
				_tmp10_ = message;
				_tmp11_ = message_get_parameters (_tmp10_, &_tmp11__length1);
				_tmp12_ = _tmp11_;
				_tmp12__length1 = _tmp11__length1;
				_tmp13_ = _tmp12_[0];
				_tmp14_ = connection_add_channel_tab (self, _tmp13_, FALSE);
				tab = _tmp14_;
				_tmp16_ = tab;
				_tmp17_ = self->server_tab;
				if (_tmp16_ == _tmp17_) {
					Message* _tmp18_ = NULL;
					gchar** _tmp19_ = NULL;
					gint _tmp19__length1 = 0;
					gchar** _tmp20_ = NULL;
					gint _tmp20__length1 = 0;
					const gchar* _tmp21_ = NULL;
					SqlClientServer* _tmp22_ = NULL;
					const gchar* _tmp23_ = NULL;
					_tmp18_ = message;
					_tmp19_ = message_get_parameters (_tmp18_, &_tmp19__length1);
					_tmp20_ = _tmp19_;
					_tmp20__length1 = _tmp19__length1;
					_tmp21_ = _tmp20_[0];
					_tmp22_ = self->server;
					_tmp23_ = _tmp22_->nickname;
					_tmp15_ = g_strcmp0 (_tmp21_, _tmp23_) == 0;
				} else {
					_tmp15_ = FALSE;
				}
				if (_tmp15_) {
					Message* _tmp24_ = NULL;
					const gchar* _tmp25_ = NULL;
					ChannelTab* _tmp26_ = NULL;
					_tmp24_ = message;
					_tmp25_ = _tmp24_->user_name;
					_tmp26_ = connection_add_channel_tab (self, _tmp25_, TRUE);
					_g_object_unref0 (tab);
					tab = _tmp26_;
				}
				_tmp27_ = tab;
				if (_tmp27_ != NULL) {
					ChannelTab* _tmp28_ = NULL;
					Message* _tmp29_ = NULL;
					_tmp28_ = tab;
					_tmp29_ = message;
					g_signal_emit_by_name (self, "new-message", _tmp28_, _tmp29_, FALSE);
				}
				_g_object_unref0 (tab);
				_g_object_unref0 (message);
				return;
			}
		}
	} else if (_tmp8_ == g_quark_from_string (IRC_RPL_TOPIC)) {
		switch (0) {
			default:
			{
				ChannelTab* tab = NULL;
				Message* _tmp30_ = NULL;
				gchar** _tmp31_ = NULL;
				gint _tmp31__length1 = 0;
				gchar** _tmp32_ = NULL;
				gint _tmp32__length1 = 0;
				const gchar* _tmp33_ = NULL;
				ChannelTab* _tmp34_ = NULL;
				gboolean _tmp35_ = FALSE;
				ChannelTab* _tmp36_ = NULL;
				_tmp30_ = message;
				_tmp31_ = message_get_parameters (_tmp30_, &_tmp31__length1);
				_tmp32_ = _tmp31_;
				_tmp32__length1 = _tmp31__length1;
				_tmp33_ = _tmp32_[1];
				_tmp34_ = connection_find_channel_tab (self, _tmp33_);
				tab = _tmp34_;
				_tmp36_ = tab;
				if (_tmp36_ != NULL) {
					ChannelTab* _tmp37_ = NULL;
					ChannelTab* _tmp38_ = NULL;
					_tmp37_ = tab;
					_tmp38_ = self->server_tab;
					_tmp35_ = _tmp37_ != _tmp38_;
				} else {
					_tmp35_ = FALSE;
				}
				if (_tmp35_) {
					ChannelTab* _tmp39_ = NULL;
					Message* _tmp40_ = NULL;
					gchar* _tmp41_ = NULL;
					gchar* _tmp42_ = NULL;
					_tmp39_ = tab;
					_tmp40_ = message;
					_tmp41_ = message_get_msg_txt (_tmp40_);
					_tmp42_ = _tmp41_;
					channel_tab_set_topic (_tmp39_, _tmp42_, FALSE);
					_g_free0 (_tmp42_);
				}
				_g_object_unref0 (tab);
				_g_object_unref0 (message);
				return;
			}
		}
	} else if (_tmp8_ == g_quark_from_string (IRC_RPL_CHANNEL_URL)) {
		switch (0) {
			default:
			{
				ChannelTab* tab = NULL;
				Message* _tmp43_ = NULL;
				gchar** _tmp44_ = NULL;
				gint _tmp44__length1 = 0;
				gchar** _tmp45_ = NULL;
				gint _tmp45__length1 = 0;
				const gchar* _tmp46_ = NULL;
				ChannelTab* _tmp47_ = NULL;
				gboolean _tmp48_ = FALSE;
				ChannelTab* _tmp49_ = NULL;
				_tmp43_ = message;
				_tmp44_ = message_get_parameters (_tmp43_, &_tmp44__length1);
				_tmp45_ = _tmp44_;
				_tmp45__length1 = _tmp44__length1;
				_tmp46_ = _tmp45_[1];
				_tmp47_ = connection_find_channel_tab (self, _tmp46_);
				tab = _tmp47_;
				_tmp49_ = tab;
				if (_tmp49_ != NULL) {
					ChannelTab* _tmp50_ = NULL;
					ChannelTab* _tmp51_ = NULL;
					_tmp50_ = tab;
					_tmp51_ = self->server_tab;
					_tmp48_ = _tmp50_ != _tmp51_;
				} else {
					_tmp48_ = FALSE;
				}
				if (_tmp48_) {
					ChannelTab* _tmp52_ = NULL;
					Message* _tmp53_ = NULL;
					const gchar* _tmp54_ = NULL;
					const gchar* _tmp55_ = NULL;
					gchar* _tmp56_ = NULL;
					_tmp52_ = tab;
					_tmp53_ = message;
					_tmp54_ = message_get_message (_tmp53_);
					_tmp55_ = _tmp54_;
					_tmp56_ = g_strdup (_tmp55_);
					_g_free0 (_tmp52_->channel_url);
					_tmp52_->channel_url = _tmp56_;
				}
				_g_object_unref0 (tab);
				_g_object_unref0 (message);
				return;
			}
		}
	} else if ((((((((((((_tmp8_ == g_quark_from_string (IRC_RPL_LUSERCLIENT)) || (_tmp8_ == ((0 != _tmp7_label2) ? _tmp7_label2 : (_tmp7_label2 = g_quark_from_static_string ("NOTICE"))))) || (_tmp8_ == g_quark_from_string (IRC_RPL_MOTD))) || (_tmp8_ == g_quark_from_string (IRC_RPL_MOTDSTART))) || (_tmp8_ == g_quark_from_string (IRC_RPL_YOURHOST))) || (_tmp8_ == g_quark_from_string (IRC_RPL_LUSEROP))) || (_tmp8_ == g_quark_from_string (IRC_RPL_LUSERUNKNOWN))) || (_tmp8_ == g_quark_from_string (IRC_RPL_LUSERCHANNELS))) || (_tmp8_ == g_quark_from_string (IRC_RPL_UMODEIS))) || (_tmp8_ == g_quark_from_string (IRC_RPL_SERVLIST))) || (_tmp8_ == g_quark_from_string (IRC_RPL_ENDOFSTATS))) || (_tmp8_ == g_quark_from_string (IRC_RPL_STATSLINKINFO))) {
		switch (0) {
			default:
			{
				ChannelTab* _tmp57_ = NULL;
				Message* _tmp58_ = NULL;
				_tmp57_ = self->server_tab;
				_tmp58_ = message;
				channel_tab_display_message (_tmp57_, _tmp58_);
				_g_object_unref0 (message);
				return;
			}
		}
	} else if ((_tmp8_ == g_quark_from_string (IRC_RPL_CREATED)) || (_tmp8_ == g_quark_from_string (IRC_RPL_LUSERME))) {
		switch (0) {
			default:
			{
				ChannelTab* _tmp59_ = NULL;
				Message* _tmp60_ = NULL;
				gchar* _tmp61_ = NULL;
				gchar* _tmp62_ = NULL;
				ChannelTab* _tmp63_ = NULL;
				Message* _tmp64_ = NULL;
				_tmp59_ = self->server_tab;
				_tmp60_ = message;
				_tmp61_ = message_get_msg_txt (_tmp60_);
				_tmp62_ = _tmp61_;
				channel_tab_set_topic (_tmp59_, _tmp62_, TRUE);
				_g_free0 (_tmp62_);
				_tmp63_ = self->server_tab;
				_tmp64_ = message;
				g_signal_emit_by_name (self, "new-message", _tmp63_, _tmp64_, FALSE);
				_g_object_unref0 (message);
				return;
			}
		}
	} else if (_tmp8_ == g_quark_from_string (IRC_RPL_WELCOME)) {
		switch (0) {
			default:
			{
				GeeLinkedList* _tmp65_ = NULL;
				gint _tmp66_ = 0;
				gint _tmp67_ = 0;
				connection_do_autoconnect (self);
				connection_run_on_connect_cmds (self);
				_tmp65_ = self->channel_autoconnect;
				_tmp66_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp65_);
				_tmp67_ = _tmp66_;
				if (_tmp67_ == 0) {
					ChannelTab* _tmp68_ = NULL;
					GraniteWidgetsTab* _tmp69_ = NULL;
					_tmp68_ = self->server_tab;
					_tmp69_ = _tmp68_->tab;
					granite_widgets_tab_set_working (_tmp69_, FALSE);
				}
				break;
			}
		}
	} else if (_tmp8_ == g_quark_from_string (IRC_RPL_NAMREPLY)) {
		switch (0) {
			default:
			{
				ChannelTab* tab = NULL;
				Message* _tmp70_ = NULL;
				gchar** _tmp71_ = NULL;
				gint _tmp71__length1 = 0;
				gchar** _tmp72_ = NULL;
				gint _tmp72__length1 = 0;
				const gchar* _tmp73_ = NULL;
				ChannelTab* _tmp74_ = NULL;
				gboolean _tmp75_ = FALSE;
				ChannelTab* _tmp76_ = NULL;
				ChannelTab* _tmp79_ = NULL;
				Message* _tmp80_ = NULL;
				_tmp70_ = message;
				_tmp71_ = message_get_parameters (_tmp70_, &_tmp71__length1);
				_tmp72_ = _tmp71_;
				_tmp72__length1 = _tmp71__length1;
				_tmp73_ = _tmp72_[2];
				_tmp74_ = connection_add_channel_tab (self, _tmp73_, FALSE);
				tab = _tmp74_;
				_tmp76_ = tab;
				if (_tmp76_ == NULL) {
					_tmp75_ = TRUE;
				} else {
					ChannelTab* _tmp77_ = NULL;
					ChannelTab* _tmp78_ = NULL;
					_tmp77_ = tab;
					_tmp78_ = self->server_tab;
					_tmp75_ = _tmp77_ == _tmp78_;
				}
				if (_tmp75_) {
					_g_object_unref0 (tab);
					_g_object_unref0 (message);
					return;
				}
				_tmp79_ = tab;
				_tmp80_ = message;
				channel_tab_add_users_message (_tmp79_, _tmp80_);
				_g_object_unref0 (tab);
				break;
			}
		}
	} else if ((_tmp8_ == g_quark_from_string (IRC_QUIT_MSG)) || (_tmp8_ == g_quark_from_string (IRC_PART_MSG))) {
		switch (0) {
			default:
			{
				{
					GeeIterator* _t_it = NULL;
					GeeHashMap* _tmp81_ = NULL;
					GeeSet* _tmp82_ = NULL;
					GeeSet* _tmp83_ = NULL;
					GeeSet* _tmp84_ = NULL;
					GeeIterator* _tmp85_ = NULL;
					GeeIterator* _tmp86_ = NULL;
					_tmp81_ = self->channel_tabs;
					_tmp82_ = gee_abstract_map_get_entries ((GeeMap*) _tmp81_);
					_tmp83_ = _tmp82_;
					_tmp84_ = _tmp83_;
					_tmp85_ = gee_iterable_iterator ((GeeIterable*) _tmp84_);
					_tmp86_ = _tmp85_;
					_g_object_unref0 (_tmp84_);
					_t_it = _tmp86_;
					while (TRUE) {
						GeeIterator* _tmp87_ = NULL;
						gboolean _tmp88_ = FALSE;
						GeeMapEntry* t = NULL;
						GeeIterator* _tmp89_ = NULL;
						gpointer _tmp90_ = NULL;
						gboolean _tmp91_ = FALSE;
						gboolean _tmp92_ = FALSE;
						gboolean _tmp93_ = FALSE;
						GeeMapEntry* _tmp94_ = NULL;
						gconstpointer _tmp95_ = NULL;
						ChannelTab* _tmp96_ = NULL;
						gboolean _tmp97_ = FALSE;
						_tmp87_ = _t_it;
						_tmp88_ = gee_iterator_next (_tmp87_);
						if (!_tmp88_) {
							break;
						}
						_tmp89_ = _t_it;
						_tmp90_ = gee_iterator_get (_tmp89_);
						t = (GeeMapEntry*) _tmp90_;
						_tmp94_ = t;
						_tmp95_ = gee_map_entry_get_value (_tmp94_);
						_tmp96_ = _tmp95_;
						_tmp97_ = ((ChannelTab*) _tmp96_)->is_server_tab;
						if (!_tmp97_) {
							GeeMapEntry* _tmp98_ = NULL;
							_tmp98_ = t;
							_tmp93_ = _tmp98_ != NULL;
						} else {
							_tmp93_ = FALSE;
						}
						if (_tmp93_) {
							Message* _tmp99_ = NULL;
							const gchar* _tmp100_ = NULL;
							_tmp99_ = message;
							_tmp100_ = _tmp99_->user_name;
							_tmp92_ = _tmp100_ != NULL;
						} else {
							_tmp92_ = FALSE;
						}
						if (_tmp92_) {
							Message* _tmp101_ = NULL;
							const gchar* _tmp102_ = NULL;
							gint _tmp103_ = 0;
							gint _tmp104_ = 0;
							_tmp101_ = message;
							_tmp102_ = _tmp101_->user_name;
							_tmp103_ = strlen (_tmp102_);
							_tmp104_ = _tmp103_;
							_tmp91_ = _tmp104_ > 0;
						} else {
							_tmp91_ = FALSE;
						}
						if (_tmp91_) {
							GeeMapEntry* _tmp105_ = NULL;
							gconstpointer _tmp106_ = NULL;
							ChannelTab* _tmp107_ = NULL;
							Message* _tmp108_ = NULL;
							const gchar* _tmp109_ = NULL;
							Message* _tmp110_ = NULL;
							gchar* _tmp111_ = NULL;
							gchar* _tmp112_ = NULL;
							_tmp105_ = t;
							_tmp106_ = gee_map_entry_get_value (_tmp105_);
							_tmp107_ = _tmp106_;
							_tmp108_ = message;
							_tmp109_ = _tmp108_->user_name;
							_tmp110_ = message;
							_tmp111_ = message_get_msg_txt (_tmp110_);
							_tmp112_ = _tmp111_;
							channel_tab_user_leave_channel ((ChannelTab*) _tmp107_, _tmp109_, _tmp112_);
							_g_free0 (_tmp112_);
						}
						_g_object_unref0 (t);
					}
					_g_object_unref0 (_t_it);
				}
				_g_object_unref0 (message);
				return;
			}
		}
	} else if (_tmp8_ == g_quark_from_string (IRC_USER_NAME_CHANGED)) {
		switch (0) {
			default:
			{
				{
					GeeIterator* _t_it = NULL;
					GeeHashMap* _tmp113_ = NULL;
					GeeSet* _tmp114_ = NULL;
					GeeSet* _tmp115_ = NULL;
					GeeSet* _tmp116_ = NULL;
					GeeIterator* _tmp117_ = NULL;
					GeeIterator* _tmp118_ = NULL;
					_tmp113_ = self->channel_tabs;
					_tmp114_ = gee_abstract_map_get_entries ((GeeMap*) _tmp113_);
					_tmp115_ = _tmp114_;
					_tmp116_ = _tmp115_;
					_tmp117_ = gee_iterable_iterator ((GeeIterable*) _tmp116_);
					_tmp118_ = _tmp117_;
					_g_object_unref0 (_tmp116_);
					_t_it = _tmp118_;
					while (TRUE) {
						GeeIterator* _tmp119_ = NULL;
						gboolean _tmp120_ = FALSE;
						GeeMapEntry* t = NULL;
						GeeIterator* _tmp121_ = NULL;
						gpointer _tmp122_ = NULL;
						gboolean _tmp123_ = FALSE;
						gboolean _tmp124_ = FALSE;
						GeeMapEntry* _tmp125_ = NULL;
						_tmp119_ = _t_it;
						_tmp120_ = gee_iterator_next (_tmp119_);
						if (!_tmp120_) {
							break;
						}
						_tmp121_ = _t_it;
						_tmp122_ = gee_iterator_get (_tmp121_);
						t = (GeeMapEntry*) _tmp122_;
						_tmp125_ = t;
						if (_tmp125_ != NULL) {
							Message* _tmp126_ = NULL;
							const gchar* _tmp127_ = NULL;
							_tmp126_ = message;
							_tmp127_ = _tmp126_->user_name;
							_tmp124_ = _tmp127_ != NULL;
						} else {
							_tmp124_ = FALSE;
						}
						if (_tmp124_) {
							Message* _tmp128_ = NULL;
							const gchar* _tmp129_ = NULL;
							gint _tmp130_ = 0;
							gint _tmp131_ = 0;
							_tmp128_ = message;
							_tmp129_ = _tmp128_->user_name;
							_tmp130_ = strlen (_tmp129_);
							_tmp131_ = _tmp130_;
							_tmp123_ = _tmp131_ > 0;
						} else {
							_tmp123_ = FALSE;
						}
						if (_tmp123_) {
							GeeMapEntry* _tmp132_ = NULL;
							gconstpointer _tmp133_ = NULL;
							ChannelTab* _tmp134_ = NULL;
							Message* _tmp135_ = NULL;
							const gchar* _tmp136_ = NULL;
							Message* _tmp137_ = NULL;
							gchar* _tmp138_ = NULL;
							gchar* _tmp139_ = NULL;
							_tmp132_ = t;
							_tmp133_ = gee_map_entry_get_value (_tmp132_);
							_tmp134_ = _tmp133_;
							_tmp135_ = message;
							_tmp136_ = _tmp135_->user_name;
							_tmp137_ = message;
							_tmp138_ = message_get_msg_txt (_tmp137_);
							_tmp139_ = _tmp138_;
							channel_tab_user_name_change ((ChannelTab*) _tmp134_, _tmp136_, _tmp139_);
							_g_free0 (_tmp139_);
						}
						_g_object_unref0 (t);
					}
					_g_object_unref0 (_t_it);
				}
				_g_object_unref0 (message);
				return;
			}
		}
	} else if (_tmp8_ == g_quark_from_string (IRC_JOIN_MSG)) {
		switch (0) {
			default:
			{
				ChannelTab* tab = NULL;
				Message* _tmp140_ = NULL;
				gchar* _tmp141_ = NULL;
				gchar* _tmp142_ = NULL;
				ChannelTab* _tmp143_ = NULL;
				ChannelTab* _tmp144_ = NULL;
				ChannelTab* _tmp145_ = NULL;
				ChannelTab* _tmp146_ = NULL;
				gboolean _tmp152_ = FALSE;
				gboolean _tmp153_ = FALSE;
				gboolean _tmp154_ = FALSE;
				ChannelTab* _tmp155_ = NULL;
				ChannelTab* _tmp156_ = NULL;
				_tmp140_ = message;
				_tmp141_ = message_get_msg_txt (_tmp140_);
				_tmp142_ = _tmp141_;
				_tmp143_ = connection_find_channel_tab (self, _tmp142_);
				_tmp144_ = _tmp143_;
				_g_free0 (_tmp142_);
				tab = _tmp144_;
				_tmp145_ = tab;
				_tmp146_ = self->server_tab;
				if (_tmp145_ == _tmp146_) {
					Message* _tmp147_ = NULL;
					gchar** _tmp148_ = NULL;
					gint _tmp148__length1 = 0;
					gchar** _tmp149_ = NULL;
					gint _tmp149__length1 = 0;
					const gchar* _tmp150_ = NULL;
					ChannelTab* _tmp151_ = NULL;
					_tmp147_ = message;
					_tmp148_ = message_get_parameters (_tmp147_, &_tmp148__length1);
					_tmp149_ = _tmp148_;
					_tmp149__length1 = _tmp148__length1;
					_tmp150_ = _tmp149_[0];
					_tmp151_ = connection_find_channel_tab (self, _tmp150_);
					_g_object_unref0 (tab);
					tab = _tmp151_;
				}
				_tmp155_ = tab;
				_tmp156_ = self->server_tab;
				if (_tmp155_ != _tmp156_) {
					ChannelTab* _tmp157_ = NULL;
					_tmp157_ = tab;
					_tmp154_ = _tmp157_ != NULL;
				} else {
					_tmp154_ = FALSE;
				}
				if (_tmp154_) {
					Message* _tmp158_ = NULL;
					const gchar* _tmp159_ = NULL;
					_tmp158_ = message;
					_tmp159_ = _tmp158_->user_name;
					_tmp153_ = _tmp159_ != NULL;
				} else {
					_tmp153_ = FALSE;
				}
				if (_tmp153_) {
					Message* _tmp160_ = NULL;
					const gchar* _tmp161_ = NULL;
					gint _tmp162_ = 0;
					gint _tmp163_ = 0;
					_tmp160_ = message;
					_tmp161_ = _tmp160_->user_name;
					_tmp162_ = strlen (_tmp161_);
					_tmp163_ = _tmp162_;
					_tmp152_ = _tmp163_ > 0;
				} else {
					_tmp152_ = FALSE;
				}
				if (_tmp152_) {
					ChannelTab* _tmp164_ = NULL;
					Message* _tmp165_ = NULL;
					const gchar* _tmp166_ = NULL;
					_tmp164_ = tab;
					_tmp165_ = message;
					_tmp166_ = _tmp165_->user_name;
					channel_tab_user_join_channel (_tmp164_, _tmp166_);
				}
				_g_object_unref0 (tab);
				_g_object_unref0 (message);
				return;
			}
		}
	} else if (_tmp8_ == g_quark_from_string (IRC_RPL_ENDOFNAMES)) {
		switch (0) {
			default:
			{
				ChannelTab* tab = NULL;
				Message* _tmp167_ = NULL;
				gchar** _tmp168_ = NULL;
				gint _tmp168__length1 = 0;
				gchar** _tmp169_ = NULL;
				gint _tmp169__length1 = 0;
				const gchar* _tmp170_ = NULL;
				ChannelTab* _tmp171_ = NULL;
				ChannelTab* _tmp172_ = NULL;
				_tmp167_ = message;
				_tmp168_ = message_get_parameters (_tmp167_, &_tmp168__length1);
				_tmp169_ = _tmp168_;
				_tmp169__length1 = _tmp168__length1;
				_tmp170_ = _tmp169_[1];
				_tmp171_ = connection_find_channel_tab (self, _tmp170_);
				tab = _tmp171_;
				_tmp172_ = tab;
				if (_tmp172_ != NULL) {
					ChannelTab* _tmp173_ = NULL;
					_tmp173_ = tab;
					channel_tab_sort_names (_tmp173_);
				}
				_g_object_unref0 (tab);
				_g_object_unref0 (message);
				return;
			}
		}
	} else if ((_tmp8_ == g_quark_from_string (IRC_ERR_NICKNAMEINUSE)) || (_tmp8_ == g_quark_from_string (IRC_ERR_NONICKNAMEGIVEN))) {
		switch (0) {
			default:
			{
				gchar* error_msg = NULL;
				Message* _tmp174_ = NULL;
				gchar* _tmp175_ = NULL;
				Message* _tmp176_ = NULL;
				gchar* _tmp177_ = NULL;
				gchar* _tmp178_ = NULL;
				gint _tmp179_ = 0;
				gint _tmp180_ = 0;
				gboolean _tmp181_ = FALSE;
				SqlClientServer* _tmp184_ = NULL;
				const gchar* _tmp185_ = NULL;
				gchar* _tmp186_ = NULL;
				gchar* _tmp187_ = NULL;
				const gchar* _tmp188_ = NULL;
				gchar* _tmp189_ = NULL;
				const gchar* _tmp190_ = NULL;
				_tmp174_ = message;
				_tmp175_ = message_get_msg_txt (_tmp174_);
				error_msg = _tmp175_;
				_tmp176_ = message;
				_tmp177_ = message_get_msg_txt (_tmp176_);
				_tmp178_ = _tmp177_;
				_tmp179_ = strlen (_tmp178_);
				_tmp180_ = _tmp179_;
				_tmp181_ = _tmp180_ < 3;
				_g_free0 (_tmp178_);
				if (_tmp181_) {
					const gchar* _tmp182_ = NULL;
					gchar* _tmp183_ = NULL;
					_tmp182_ = _ ("The name you chose is in use.");
					_tmp183_ = g_strdup (_tmp182_);
					_g_free0 (error_msg);
					error_msg = _tmp183_;
				}
				_tmp184_ = self->server;
				_tmp185_ = _tmp184_->host;
				_tmp186_ = g_strconcat (_tmp185_, "\n", NULL);
				_tmp187_ = _tmp186_;
				_tmp188_ = error_msg;
				_tmp189_ = g_strconcat (_tmp187_, _tmp188_, NULL);
				_g_free0 (error_msg);
				error_msg = _tmp189_;
				_g_free0 (_tmp187_);
				_tmp190_ = error_msg;
				connection_name_in_use (self, _tmp190_);
				_g_free0 (error_msg);
				_g_object_unref0 (message);
				return;
			}
		}
	} else if (_tmp8_ == g_quark_from_string (IRC_ERR_LINKCHANNEL)) {
		switch (0) {
			default:
			{
				Message* _tmp191_ = NULL;
				gchar** _tmp192_ = NULL;
				gint _tmp192__length1 = 0;
				gchar** _tmp193_ = NULL;
				gint _tmp193__length1 = 0;
				Message* _tmp194_ = NULL;
				gchar** _tmp195_ = NULL;
				gint _tmp195__length1 = 0;
				gchar** _tmp196_ = NULL;
				gint _tmp196__length1 = 0;
				const gchar* _tmp197_ = NULL;
				_tmp191_ = message;
				_tmp192_ = message_get_parameters (_tmp191_, &_tmp192__length1);
				_tmp193_ = _tmp192_;
				_tmp193__length1 = _tmp192__length1;
				if (_tmp193__length1 < 2) {
					_g_object_unref0 (message);
					return;
				}
				_tmp194_ = message;
				_tmp195_ = message_get_parameters (_tmp194_, &_tmp195__length1);
				_tmp196_ = _tmp195_;
				_tmp196__length1 = _tmp195__length1;
				_tmp197_ = _tmp196_[1];
				connection_turn_off_icon (self, _tmp197_);
				_g_object_unref0 (message);
				return;
			}
		}
	} else if (((((((((((((_tmp8_ == g_quark_from_string (IRC_ERR_NOSUCHNICK)) || (_tmp8_ == g_quark_from_string (IRC_ERR_NOSUCHCHANNEL))) || (_tmp8_ == g_quark_from_string (IRC_ERR_WASNOSUCHNICK))) || (_tmp8_ == g_quark_from_string (IRC_ERR_UNKNOWNCOMMAND))) || (_tmp8_ == g_quark_from_string (IRC_ERR_NOMOTD))) || (_tmp8_ == g_quark_from_string (IRC_ERR_USERNOTINCHANNEL))) || (_tmp8_ == g_quark_from_string (IRC_ERR_NOTONCHANNEL))) || (_tmp8_ == g_quark_from_string (IRC_ERR_NOTREGISTERED))) || (_tmp8_ == g_quark_from_string (IRC_ERR_NEEDMOREPARAMS))) || (_tmp8_ == g_quark_from_string (IRC_ERR_UNKNOWNMODE))) || (_tmp8_ == g_quark_from_string (IRC_ERR_ALREADYONCHANNEL))) || (_tmp8_ == g_quark_from_string (IRC_ERR_CHANOPRIVSNEEDED))) || (_tmp8_ == g_quark_from_string (IRC_ERR_NONONREG))) {
		switch (0) {
			default:
			{
				Message* _tmp198_ = NULL;
				gchar** _tmp199_ = NULL;
				gint _tmp199__length1 = 0;
				gchar** _tmp200_ = NULL;
				gint _tmp200__length1 = 0;
				const gchar* _tmp201_ = NULL;
				ChannelTab* _tmp202_ = NULL;
				ChannelTab* _tmp203_ = NULL;
				Message* _tmp204_ = NULL;
				_tmp198_ = message;
				_tmp199_ = message_get_parameters (_tmp198_, &_tmp199__length1);
				_tmp200_ = _tmp199_;
				_tmp200__length1 = _tmp199__length1;
				_tmp201_ = _tmp200_[0];
				_tmp202_ = connection_find_channel_tab (self, _tmp201_);
				_tmp203_ = _tmp202_;
				_tmp204_ = message;
				g_signal_emit_by_name (self, "new-message", _tmp203_, _tmp204_, TRUE);
				_g_object_unref0 (_tmp203_);
				_g_object_unref0 (message);
				return;
			}
		}
	} else {
		switch (0) {
			default:
			{
				Message* _tmp205_ = NULL;
				const gchar* _tmp206_ = NULL;
				const gchar* _tmp207_ = NULL;
				const gchar* _tmp228_ = NULL;
				gchar* _tmp229_ = NULL;
				gchar* _tmp230_ = NULL;
				_tmp205_ = message;
				_tmp206_ = message_get_command (_tmp205_);
				_tmp207_ = _tmp206_;
				if (_tmp207_ == NULL) {
					Message* _tmp208_ = NULL;
					_tmp208_ = message;
					message_set_command (_tmp208_, "0");
				} else {
					gint mode = 0;
					Message* _tmp209_ = NULL;
					const gchar* _tmp210_ = NULL;
					const gchar* _tmp211_ = NULL;
					gint _tmp212_ = 0;
					gboolean _tmp213_ = FALSE;
					gboolean _tmp214_ = FALSE;
					gboolean _tmp215_ = FALSE;
					Message* _tmp216_ = NULL;
					const gchar* _tmp217_ = NULL;
					const gchar* _tmp218_ = NULL;
					_tmp209_ = message;
					_tmp210_ = message_get_command (_tmp209_);
					_tmp211_ = _tmp210_;
					_tmp212_ = atoi (_tmp211_);
					mode = _tmp212_;
					_tmp216_ = message;
					_tmp217_ = message_get_command (_tmp216_);
					_tmp218_ = _tmp217_;
					if (g_strcmp0 (_tmp218_, "ERROR") == 0) {
						_tmp215_ = TRUE;
					} else {
						gboolean _tmp219_ = FALSE;
						gint _tmp220_ = 0;
						_tmp220_ = mode;
						if (_tmp220_ <= 533) {
							gint _tmp221_ = 0;
							_tmp221_ = mode;
							_tmp219_ = _tmp221_ >= 400;
						} else {
							_tmp219_ = FALSE;
						}
						_tmp215_ = _tmp219_;
					}
					if (_tmp215_) {
						_tmp214_ = TRUE;
					} else {
						gboolean _tmp222_ = FALSE;
						gint _tmp223_ = 0;
						_tmp223_ = mode;
						if (_tmp223_ >= 712) {
							gint _tmp224_ = 0;
							_tmp224_ = mode;
							_tmp222_ = _tmp224_ <= 715;
						} else {
							_tmp222_ = FALSE;
						}
						_tmp214_ = _tmp222_;
					}
					if (_tmp214_) {
						_tmp213_ = TRUE;
					} else {
						gint _tmp225_ = 0;
						_tmp225_ = mode;
						_tmp213_ = _tmp225_ >= 972;
					}
					if (_tmp213_) {
						ChannelTab* _tmp226_ = NULL;
						Message* _tmp227_ = NULL;
						_tmp226_ = self->server_tab;
						_tmp227_ = message;
						g_signal_emit_by_name (self, "new-message", _tmp226_, _tmp227_, TRUE);
						_g_object_unref0 (message);
						return;
					}
				}
				_tmp228_ = msg;
				_tmp229_ = g_strconcat ("Unhandled message: ", _tmp228_, NULL);
				_tmp230_ = _tmp229_;
				g_debug ("connection.vala:261: %s", _tmp230_);
				_g_free0 (_tmp230_);
				_g_object_unref0 (message);
				return;
			}
		}
	}
	_g_object_unref0 (message);
}


void connection_do_register (Connection* self) {
	const gchar* _tmp0_ = NULL;
	SqlClientServer* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	SqlClientServer* _tmp9_ = NULL;
	const gchar* _tmp10_ = NULL;
	gchar* _tmp11_ = NULL;
	gchar* _tmp12_ = NULL;
	SqlClientServer* _tmp13_ = NULL;
	const gchar* _tmp14_ = NULL;
	gchar* _tmp15_ = NULL;
	gchar* _tmp16_ = NULL;
	gchar* _tmp17_ = NULL;
	gchar* _tmp18_ = NULL;
	SqlClientServer* _tmp19_ = NULL;
	const gchar* _tmp20_ = NULL;
	gchar* _tmp21_ = NULL;
	gchar* _tmp22_ = NULL;
	SqlClientServer* _tmp23_ = NULL;
	const gchar* _tmp24_ = NULL;
	gchar* _tmp25_ = NULL;
	gchar* _tmp26_ = NULL;
	gchar* _tmp27_ = NULL;
	gchar* _tmp28_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp1_ = self->server;
	_tmp2_ = _tmp1_->password;
	_tmp3_ = strlen (_tmp2_);
	_tmp4_ = _tmp3_;
	if (_tmp4_ > 0) {
		SqlClientServer* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		_tmp5_ = self->server;
		_tmp6_ = _tmp5_->password;
		_tmp0_ = _tmp6_;
	} else {
		_tmp0_ = "-p";
	}
	_tmp7_ = g_strconcat ("PASS  ", _tmp0_, NULL);
	_tmp8_ = _tmp7_;
	connection_send_output (self, _tmp8_);
	_g_free0 (_tmp8_);
	_tmp9_ = self->server;
	_tmp10_ = _tmp9_->nickname;
	_tmp11_ = g_strconcat ("NICK ", _tmp10_, NULL);
	_tmp12_ = _tmp11_;
	connection_send_output (self, _tmp12_);
	_g_free0 (_tmp12_);
	_tmp13_ = self->server;
	_tmp14_ = _tmp13_->username;
	_tmp15_ = g_strconcat ("USER ", _tmp14_, NULL);
	_tmp16_ = _tmp15_;
	_tmp17_ = g_strconcat (_tmp16_, " 0 * :", NULL);
	_tmp18_ = _tmp17_;
	_tmp19_ = self->server;
	_tmp20_ = _tmp19_->realname;
	_tmp21_ = g_strconcat (_tmp18_, _tmp20_, NULL);
	_tmp22_ = _tmp21_;
	connection_send_output (self, _tmp22_);
	_g_free0 (_tmp22_);
	_g_free0 (_tmp18_);
	_g_free0 (_tmp16_);
	_tmp23_ = self->server;
	_tmp24_ = _tmp23_->username;
	_tmp25_ = g_strconcat ("MODE ", _tmp24_, NULL);
	_tmp26_ = _tmp25_;
	_tmp27_ = g_strconcat (_tmp26_, " +i", NULL);
	_tmp28_ = _tmp27_;
	connection_send_output (self, _tmp28_);
	_g_free0 (_tmp28_);
	_g_free0 (_tmp26_);
}


static gboolean __lambda20_ (Connection* self) {
	gboolean result = FALSE;
	{
		GeeLinkedList* _chan_list = NULL;
		GeeLinkedList* _tmp0_ = NULL;
		GeeLinkedList* _tmp1_ = NULL;
		gint _chan_size = 0;
		GeeLinkedList* _tmp2_ = NULL;
		gint _tmp3_ = 0;
		gint _tmp4_ = 0;
		gint _chan_index = 0;
		_tmp0_ = self->channel_autoconnect;
		_tmp1_ = _g_object_ref0 (_tmp0_);
		_chan_list = _tmp1_;
		_tmp2_ = _chan_list;
		_tmp3_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp2_);
		_tmp4_ = _tmp3_;
		_chan_size = _tmp4_;
		_chan_index = -1;
		while (TRUE) {
			gint _tmp5_ = 0;
			gint _tmp6_ = 0;
			gint _tmp7_ = 0;
			gchar* chan = NULL;
			GeeLinkedList* _tmp8_ = NULL;
			gint _tmp9_ = 0;
			gpointer _tmp10_ = NULL;
			const gchar* _tmp11_ = NULL;
			_tmp5_ = _chan_index;
			_chan_index = _tmp5_ + 1;
			_tmp6_ = _chan_index;
			_tmp7_ = _chan_size;
			if (!(_tmp6_ < _tmp7_)) {
				break;
			}
			_tmp8_ = _chan_list;
			_tmp9_ = _chan_index;
			_tmp10_ = gee_abstract_list_get ((GeeAbstractList*) _tmp8_, _tmp9_);
			chan = (gchar*) _tmp10_;
			_tmp11_ = chan;
			g_signal_emit_by_name (self, "change-channel-state", _tmp11_, "stuck");
			_g_free0 (chan);
		}
		_g_object_unref0 (_chan_list);
	}
	result = FALSE;
	return result;
}


static gboolean ___lambda20__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda20_ ((Connection*) self);
	return result;
}


void connection_do_autoconnect (Connection* self) {
	g_return_if_fail (self != NULL);
	self->autoconnect_ran = TRUE;
	{
		GeeLinkedList* _chan_list = NULL;
		GeeLinkedList* _tmp0_ = NULL;
		GeeLinkedList* _tmp1_ = NULL;
		gint _chan_size = 0;
		GeeLinkedList* _tmp2_ = NULL;
		gint _tmp3_ = 0;
		gint _tmp4_ = 0;
		gint _chan_index = 0;
		_tmp0_ = self->channel_autoconnect;
		_tmp1_ = _g_object_ref0 (_tmp0_);
		_chan_list = _tmp1_;
		_tmp2_ = _chan_list;
		_tmp3_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp2_);
		_tmp4_ = _tmp3_;
		_chan_size = _tmp4_;
		_chan_index = -1;
		while (TRUE) {
			gint _tmp5_ = 0;
			gint _tmp6_ = 0;
			gint _tmp7_ = 0;
			gchar* chan = NULL;
			GeeLinkedList* _tmp8_ = NULL;
			gint _tmp9_ = 0;
			gpointer _tmp10_ = NULL;
			const gchar* _tmp11_ = NULL;
			_tmp5_ = _chan_index;
			_chan_index = _tmp5_ + 1;
			_tmp6_ = _chan_index;
			_tmp7_ = _chan_size;
			if (!(_tmp6_ < _tmp7_)) {
				break;
			}
			_tmp8_ = _chan_list;
			_tmp9_ = _chan_index;
			_tmp10_ = gee_abstract_list_get ((GeeAbstractList*) _tmp8_, _tmp9_);
			chan = (gchar*) _tmp10_;
			_tmp11_ = chan;
			connection_join (self, _tmp11_);
			_g_free0 (chan);
		}
		_g_object_unref0 (_chan_list);
	}
	gdk_threads_add_timeout_seconds ((guint) 25, ___lambda20__gsource_func, self);
}


void connection_turn_off_icon (Connection* self, const gchar* channel) {
	const gchar* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (channel != NULL);
	_tmp0_ = channel;
	g_signal_emit_by_name (self, "change-channel-state", _tmp0_, "inactive");
}


void connection_run_on_connect_cmds (Connection* self) {
	gboolean _tmp0_ = FALSE;
	SqlClientServer* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp1_ = self->server;
	_tmp2_ = _tmp1_->connect_cmds;
	if (_tmp2_ != NULL) {
		SqlClientServer* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		gint _tmp5_ = 0;
		gint _tmp6_ = 0;
		_tmp3_ = self->server;
		_tmp4_ = _tmp3_->connect_cmds;
		_tmp5_ = strlen (_tmp4_);
		_tmp6_ = _tmp5_;
		_tmp0_ = _tmp6_ > 0;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gchar** cmds = NULL;
		SqlClientServer* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		gchar** _tmp9_ = NULL;
		gchar** _tmp10_ = NULL;
		gint cmds_length1 = 0;
		gint _cmds_size_ = 0;
		gchar** _tmp11_ = NULL;
		gint _tmp11__length1 = 0;
		_tmp7_ = self->server;
		_tmp8_ = _tmp7_->connect_cmds;
		_tmp10_ = _tmp9_ = g_strsplit (_tmp8_, "\n", 0);
		cmds = _tmp10_;
		cmds_length1 = _vala_array_length (_tmp9_);
		_cmds_size_ = cmds_length1;
		_tmp11_ = cmds;
		_tmp11__length1 = cmds_length1;
		{
			gchar** run_collection = NULL;
			gint run_collection_length1 = 0;
			gint _run_collection_size_ = 0;
			gint run_it = 0;
			run_collection = _tmp11_;
			run_collection_length1 = _tmp11__length1;
			for (run_it = 0; run_it < _tmp11__length1; run_it = run_it + 1) {
				gchar* _tmp12_ = NULL;
				gchar* run = NULL;
				_tmp12_ = g_strdup (run_collection[run_it]);
				run = _tmp12_;
				{
					const gchar* _tmp13_ = NULL;
					gint _tmp14_ = 0;
					gint _tmp15_ = 0;
					_tmp13_ = run;
					_tmp14_ = strlen (_tmp13_);
					_tmp15_ = _tmp14_;
					if (_tmp15_ > 1) {
						ChannelTab* _tmp16_ = NULL;
						const gchar* _tmp17_ = NULL;
						_tmp16_ = self->server_tab;
						_tmp17_ = run;
						channel_tab_send_text_out (_tmp16_, _tmp17_);
					}
					_g_free0 (run);
				}
			}
		}
		cmds = (_vala_array_free (cmds, cmds_length1, (GDestroyNotify) g_free), NULL);
	}
}


static Block17Data* block17_data_ref (Block17Data* _data17_) {
	g_atomic_int_inc (&_data17_->_ref_count_);
	return _data17_;
}


static void block17_data_unref (void * _userdata_) {
	Block17Data* _data17_;
	_data17_ = (Block17Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data17_->_ref_count_)) {
		Connection* self;
		self = _data17_->self;
		_g_free0 (_data17_->message);
		_g_object_unref0 (self);
		g_slice_free (Block17Data, _data17_);
	}
}


static Block18Data* block18_data_ref (Block18Data* _data18_) {
	g_atomic_int_inc (&_data18_->_ref_count_);
	return _data18_;
}


static void block18_data_unref (void * _userdata_) {
	Block18Data* _data18_;
	_data18_ = (Block18Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data18_->_ref_count_)) {
		Connection* self;
		self = _data18_->_data17_->self;
		_g_object_unref0 (_data18_->server_name);
		_g_object_unref0 (_data18_->dialog);
		block17_data_unref (_data18_->_data17_);
		_data18_->_data17_ = NULL;
		g_slice_free (Block18Data, _data18_);
	}
}


static void __lambda22_ (Block18Data* _data18_) {
	Block17Data* _data17_;
	Connection* self;
	_data17_ = _data18_->_data17_;
	self = _data17_->self;
	gtk_dialog_response (_data18_->dialog, (gint) GTK_RESPONSE_ACCEPT);
}


static void ___lambda22__gtk_entry_activate (GtkEntry* _sender, gpointer self) {
	__lambda22_ (self);
}


static void __lambda23_ (Block18Data* _data18_, gint id) {
	Block17Data* _data17_;
	Connection* self;
	gint _tmp0_ = 0;
	_data17_ = _data18_->_data17_;
	self = _data17_->self;
	_tmp0_ = id;
	switch (_tmp0_) {
		case GTK_RESPONSE_ACCEPT:
		{
			gchar* name = NULL;
			const gchar* _tmp1_ = NULL;
			gchar* _tmp2_ = NULL;
			const gchar* _tmp3_ = NULL;
			gint _tmp4_ = 0;
			gint _tmp5_ = 0;
			_tmp1_ = gtk_entry_get_text (_data18_->server_name);
			_tmp2_ = string_strip (_tmp1_);
			name = _tmp2_;
			_tmp3_ = name;
			_tmp4_ = strlen (_tmp3_);
			_tmp5_ = _tmp4_;
			if (_tmp5_ > 0) {
				SqlClientServer* _tmp6_ = NULL;
				SqlClientServer* _tmp7_ = NULL;
				const gchar* _tmp8_ = NULL;
				gchar* _tmp9_ = NULL;
				const gchar* _tmp10_ = NULL;
				gchar* _tmp11_ = NULL;
				SqlClientServer* _tmp12_ = NULL;
				const gchar* _tmp13_ = NULL;
				gint _tmp14_ = 0;
				gint _tmp15_ = 0;
				_tmp6_ = self->server;
				_tmp7_ = self->server;
				_tmp8_ = gtk_entry_get_text (_data18_->server_name);
				_tmp9_ = g_strdup (_tmp8_);
				_g_free0 (_tmp7_->username);
				_tmp7_->username = _tmp9_;
				_tmp10_ = _tmp7_->username;
				_tmp11_ = g_strdup (_tmp10_);
				_g_free0 (_tmp6_->nickname);
				_tmp6_->nickname = _tmp11_;
				_tmp12_ = self->server;
				_tmp13_ = _tmp12_->realname;
				_tmp14_ = strlen (_tmp13_);
				_tmp15_ = _tmp14_;
				if (_tmp15_ == 0) {
					SqlClientServer* _tmp16_ = NULL;
					SqlClientServer* _tmp17_ = NULL;
					const gchar* _tmp18_ = NULL;
					gchar* _tmp19_ = NULL;
					_tmp16_ = self->server;
					_tmp17_ = self->server;
					_tmp18_ = _tmp17_->nickname;
					_tmp19_ = g_strdup (_tmp18_);
					_g_free0 (_tmp16_->realname);
					_tmp16_->realname = _tmp19_;
				}
				connection_do_register (self);
				g_signal_emit_by_name (_data18_->dialog, "close");
			}
			_g_free0 (name);
			break;
		}
		case GTK_RESPONSE_CANCEL:
		{
			ChannelTab* _tmp20_ = NULL;
			GraniteWidgetsTab* _tmp21_ = NULL;
			g_signal_emit_by_name (_data18_->dialog, "close");
			_tmp20_ = self->server_tab;
			_tmp21_ = _tmp20_->tab;
			granite_widgets_tab_close (_tmp21_);
			{
				GeeIterator* _tab_it = NULL;
				GeeHashMap* _tmp22_ = NULL;
				GeeSet* _tmp23_ = NULL;
				GeeSet* _tmp24_ = NULL;
				GeeSet* _tmp25_ = NULL;
				GeeIterator* _tmp26_ = NULL;
				GeeIterator* _tmp27_ = NULL;
				_tmp22_ = self->channel_tabs;
				_tmp23_ = gee_abstract_map_get_entries ((GeeMap*) _tmp22_);
				_tmp24_ = _tmp23_;
				_tmp25_ = _tmp24_;
				_tmp26_ = gee_iterable_iterator ((GeeIterable*) _tmp25_);
				_tmp27_ = _tmp26_;
				_g_object_unref0 (_tmp25_);
				_tab_it = _tmp27_;
				while (TRUE) {
					GeeIterator* _tmp28_ = NULL;
					gboolean _tmp29_ = FALSE;
					GeeMapEntry* tab = NULL;
					GeeIterator* _tmp30_ = NULL;
					gpointer _tmp31_ = NULL;
					GeeMapEntry* _tmp32_ = NULL;
					gconstpointer _tmp33_ = NULL;
					ChannelTab* _tmp34_ = NULL;
					GraniteWidgetsTab* _tmp35_ = NULL;
					_tmp28_ = _tab_it;
					_tmp29_ = gee_iterator_next (_tmp28_);
					if (!_tmp29_) {
						break;
					}
					_tmp30_ = _tab_it;
					_tmp31_ = gee_iterator_get (_tmp30_);
					tab = (GeeMapEntry*) _tmp31_;
					_tmp32_ = tab;
					_tmp33_ = gee_map_entry_get_value (_tmp32_);
					_tmp34_ = _tmp33_;
					_tmp35_ = ((ChannelTab*) _tmp34_)->tab;
					granite_widgets_tab_close (_tmp35_);
					_g_object_unref0 (tab);
				}
				_g_object_unref0 (_tab_it);
			}
			break;
		}
		default:
		break;
	}
}


static void ___lambda23__gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self) {
	__lambda23_ (self, response_id);
}


static gboolean __lambda21_ (Block17Data* _data17_) {
	Connection* self;
	gboolean result = FALSE;
	Block18Data* _data18_;
	const gchar* _tmp0_ = NULL;
	GtkWindow* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	GtkDialog* _tmp4_ = NULL;
	GtkBox* content = NULL;
	GtkBox* _tmp5_ = NULL;
	GtkBox* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	GtkLabel* _tmp9_ = NULL;
	GtkLabel* _tmp10_ = NULL;
	GtkEntry* _tmp11_ = NULL;
	const gchar* _tmp12_ = NULL;
	self = _data17_->self;
	_data18_ = g_slice_new0 (Block18Data);
	_data18_->_ref_count_ = 1;
	_data18_->_data17_ = block17_data_ref (_data17_);
	_tmp0_ = _ ("Nickname in use");
	_tmp1_ = main_window_window;
	_tmp2_ = _ ("Connect");
	_tmp3_ = _ ("Cancel");
	_tmp4_ = (GtkDialog*) gtk_dialog_new_with_buttons (_tmp0_, _tmp1_, GTK_DIALOG_DESTROY_WITH_PARENT, _tmp2_, GTK_RESPONSE_ACCEPT, _tmp3_, GTK_RESPONSE_CANCEL, NULL);
	g_object_ref_sink (_tmp4_);
	_data18_->dialog = _tmp4_;
	_tmp5_ = (GtkBox*) gtk_dialog_get_content_area (_data18_->dialog);
	_tmp6_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp5_, gtk_box_get_type ()) ? ((GtkBox*) _tmp5_) : NULL);
	content = _tmp6_;
	_tmp7_ = _data17_->message;
	_tmp8_ = _ (_tmp7_);
	_tmp9_ = (GtkLabel*) gtk_label_new (_tmp8_);
	g_object_ref_sink (_tmp9_);
	_tmp10_ = _tmp9_;
	gtk_box_pack_start (content, (GtkWidget*) _tmp10_, FALSE, FALSE, (guint) 5);
	_g_object_unref0 (_tmp10_);
	_tmp11_ = (GtkEntry*) gtk_entry_new ();
	g_object_ref_sink (_tmp11_);
	_data18_->server_name = _tmp11_;
	_tmp12_ = _ ("New username");
	gtk_entry_set_placeholder_text (_data18_->server_name, _tmp12_);
	g_signal_connect_data (_data18_->server_name, "activate", (GCallback) ___lambda22__gtk_entry_activate, block18_data_ref (_data18_), (GClosureNotify) block18_data_unref, 0);
	gtk_box_pack_start (content, (GtkWidget*) _data18_->server_name, FALSE, FALSE, (guint) 5);
	gtk_widget_show_all ((GtkWidget*) _data18_->dialog);
	g_signal_connect_data (_data18_->dialog, "response", (GCallback) ___lambda23__gtk_dialog_response, block18_data_ref (_data18_), (GClosureNotify) block18_data_unref, 0);
	result = FALSE;
	_g_object_unref0 (content);
	block18_data_unref (_data18_);
	_data18_ = NULL;
	return result;
}


static gboolean ___lambda21__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda21_ (self);
	return result;
}


void connection_name_in_use (Connection* self, const gchar* message) {
	Block17Data* _data17_;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (message != NULL);
	_data17_ = g_slice_new0 (Block17Data);
	_data17_->_ref_count_ = 1;
	_data17_->self = g_object_ref (self);
	_tmp0_ = message;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (_data17_->message);
	_data17_->message = _tmp1_;
	g_debug ("connection.vala:301: At name in use");
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ___lambda21__gsource_func, block17_data_ref (_data17_), block17_data_unref);
	block17_data_unref (_data17_);
	_data17_ = NULL;
}


static void connection_handle_ping (Connection* self, Message** msg) {
	Message* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (*msg != NULL);
	_tmp0_ = *msg;
	_tmp1_ = message_get_message (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strconcat ("PONG ", _tmp2_, NULL);
	_tmp4_ = _tmp3_;
	connection_send_output (self, _tmp4_);
	_g_free0 (_tmp4_);
}


void connection_join (Connection* self, const gchar* channel) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (channel != NULL);
	_tmp0_ = channel;
	_tmp1_ = g_strconcat ("JOIN ", _tmp0_, NULL);
	_tmp2_ = _tmp1_;
	connection_send_output (self, _tmp2_);
	_g_free0 (_tmp2_);
}


void connection_send_output (Connection* self, const gchar* output) {
	GDataOutputStream* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	SqlClientServer* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	gchar* _tmp11_ = NULL;
	gchar* _tmp12_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (output != NULL);
	_tmp0_ = self->priv->output_stream;
	_tmp1_ = connection_is_stream_out (self, _tmp0_);
	if (!_tmp1_) {
		return;
	}
	_tmp2_ = output;
	_tmp3_ = g_strconcat ("Sending out ", _tmp2_, NULL);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_strconcat (_tmp4_, "  ", NULL);
	_tmp6_ = _tmp5_;
	_tmp7_ = self->server;
	_tmp8_ = _tmp7_->host;
	_tmp9_ = g_strconcat (_tmp6_, _tmp8_, NULL);
	_tmp10_ = _tmp9_;
	_tmp11_ = g_strconcat (_tmp10_, "\n", NULL);
	_tmp12_ = _tmp11_;
	g_debug ("connection.vala:352: %s", _tmp12_);
	_g_free0 (_tmp12_);
	_g_free0 (_tmp10_);
	_g_free0 (_tmp6_);
	_g_free0 (_tmp4_);
	{
		GDataOutputStream* _tmp13_ = NULL;
		const gchar* _tmp14_ = NULL;
		gchar* _tmp15_ = NULL;
		gchar* _tmp16_ = NULL;
		_tmp13_ = self->priv->output_stream;
		_tmp14_ = output;
		_tmp15_ = g_strconcat (_tmp14_, "\r\n", NULL);
		_tmp16_ = _tmp15_;
		g_data_output_stream_put_string (_tmp13_, _tmp16_, NULL, &_inner_error_);
		_g_free0 (_tmp16_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch11_g_error;
		}
	}
	goto __finally11;
	__catch11_g_error:
	{
		GError* e = NULL;
		GError* _tmp17_ = NULL;
		const gchar* _tmp18_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp17_ = e;
		_tmp18_ = _tmp17_->message;
		relay_show_error_window (_tmp18_);
		_g_error_free0 (e);
	}
	__finally11:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


gboolean connection_is_stream_out (Connection* self, GDataOutputStream* output) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	GDataOutputStream* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp2_ = output;
	if (!G_TYPE_CHECK_INSTANCE_TYPE (_tmp2_, g_data_output_stream_get_type ())) {
		_tmp1_ = TRUE;
	} else {
		GDataOutputStream* _tmp3_ = NULL;
		_tmp3_ = output;
		_tmp1_ = _tmp3_ == NULL;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		GDataOutputStream* _tmp4_ = NULL;
		gboolean _tmp5_ = FALSE;
		_tmp4_ = output;
		_tmp5_ = g_output_stream_is_closed ((GOutputStream*) _tmp4_);
		_tmp0_ = _tmp5_;
	}
	result = !_tmp0_;
	return result;
}


gboolean connection_is_stream_in (Connection* self, GDataInputStream* input) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	GDataInputStream* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp2_ = input;
	if (!G_TYPE_CHECK_INSTANCE_TYPE (_tmp2_, g_data_input_stream_get_type ())) {
		_tmp1_ = TRUE;
	} else {
		GDataInputStream* _tmp3_ = NULL;
		_tmp3_ = input;
		_tmp1_ = _tmp3_ == NULL;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		GDataInputStream* _tmp4_ = NULL;
		gboolean _tmp5_ = FALSE;
		_tmp4_ = input;
		_tmp5_ = g_input_stream_is_closed ((GInputStream*) _tmp4_);
		_tmp0_ = _tmp5_;
	}
	result = !_tmp0_;
	return result;
}


void connection_do_exit (Connection* self) {
	const gchar* _tmp12_ = NULL;
	gchar* _tmp13_ = NULL;
	gchar* _tmp14_ = NULL;
	g_return_if_fail (self != NULL);
	self->exit = TRUE;
	{
		GeeLinkedList* _chan_list = NULL;
		GeeLinkedList* _tmp0_ = NULL;
		GeeLinkedList* _tmp1_ = NULL;
		gint _chan_size = 0;
		GeeLinkedList* _tmp2_ = NULL;
		gint _tmp3_ = 0;
		gint _tmp4_ = 0;
		gint _chan_index = 0;
		_tmp0_ = self->channel_autoconnect;
		_tmp1_ = _g_object_ref0 (_tmp0_);
		_chan_list = _tmp1_;
		_tmp2_ = _chan_list;
		_tmp3_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp2_);
		_tmp4_ = _tmp3_;
		_chan_size = _tmp4_;
		_chan_index = -1;
		while (TRUE) {
			gint _tmp5_ = 0;
			gint _tmp6_ = 0;
			gint _tmp7_ = 0;
			gchar* chan = NULL;
			GeeLinkedList* _tmp8_ = NULL;
			gint _tmp9_ = 0;
			gpointer _tmp10_ = NULL;
			const gchar* _tmp11_ = NULL;
			_tmp5_ = _chan_index;
			_chan_index = _tmp5_ + 1;
			_tmp6_ = _chan_index;
			_tmp7_ = _chan_size;
			if (!(_tmp6_ < _tmp7_)) {
				break;
			}
			_tmp8_ = _chan_list;
			_tmp9_ = _chan_index;
			_tmp10_ = gee_abstract_list_get ((GeeAbstractList*) _tmp8_, _tmp9_);
			chan = (gchar*) _tmp10_;
			_tmp11_ = chan;
			connection_turn_off_icon (self, _tmp11_);
			_g_free0 (chan);
		}
		_g_object_unref0 (_chan_list);
	}
	_tmp12_ = _ ("Relay, an IRC client for the modern desktop");
	_tmp13_ = g_strconcat ("QUIT :", _tmp12_, NULL);
	_tmp14_ = _tmp13_;
	connection_send_output (self, _tmp14_);
	_g_free0 (_tmp14_);
	connection_stop (self);
}


void connection_stop (Connection* self) {
	GDataInputStream* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	GDataOutputStream* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	self->exit = TRUE;
	_tmp0_ = self->priv->input_stream;
	_tmp1_ = connection_is_stream_in (self, _tmp0_);
	if (_tmp1_) {
		GDataInputStream* _tmp2_ = NULL;
		_tmp2_ = self->priv->input_stream;
		g_input_stream_clear_pending ((GInputStream*) _tmp2_);
		{
			GDataInputStream* _tmp3_ = NULL;
			_tmp3_ = self->priv->input_stream;
			g_input_stream_close ((GInputStream*) _tmp3_, NULL, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				if (_inner_error_->domain == G_IO_ERROR) {
					goto __catch12_g_io_error;
				}
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
		goto __finally12;
		__catch12_g_io_error:
		{
			GError* e = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_g_error_free0 (e);
		}
		__finally12:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp4_ = self->priv->output_stream;
	_tmp5_ = connection_is_stream_out (self, _tmp4_);
	if (_tmp5_) {
		{
			GDataOutputStream* _tmp6_ = NULL;
			GDataOutputStream* _tmp7_ = NULL;
			GDataOutputStream* _tmp8_ = NULL;
			_tmp6_ = self->priv->output_stream;
			g_output_stream_clear_pending ((GOutputStream*) _tmp6_);
			_tmp7_ = self->priv->output_stream;
			g_output_stream_flush ((GOutputStream*) _tmp7_, NULL, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				goto __catch13_g_error;
			}
			_tmp8_ = self->priv->output_stream;
			g_output_stream_close ((GOutputStream*) _tmp8_, NULL, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				goto __catch13_g_error;
			}
		}
		goto __finally13;
		__catch13_g_error:
		{
			GError* e = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_g_error_free0 (e);
		}
		__finally13:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	g_debug ("connection.vala:394: Sucessfully stopped");
}


Connection* connection_construct (GType object_type) {
	Connection * self = NULL;
	self = (Connection*) g_object_new (object_type, NULL);
	return self;
}


Connection* connection_new (void) {
	return connection_construct (TYPE_CONNECTION);
}


static void g_cclosure_user_marshal_VOID__OBJECT_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__OBJECT_STRING) (gpointer data1, gpointer arg_1, const char* arg_2, gpointer data2);
	register GMarshalFunc_VOID__OBJECT_STRING callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__OBJECT_STRING) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_object (param_values + 1), g_value_get_string (param_values + 2), data2);
}


static void g_cclosure_user_marshal_VOID__OBJECT_OBJECT_BOOLEAN (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__OBJECT_OBJECT_BOOLEAN) (gpointer data1, gpointer arg_1, gpointer arg_2, gboolean arg_3, gpointer data2);
	register GMarshalFunc_VOID__OBJECT_OBJECT_BOOLEAN callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 4);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__OBJECT_OBJECT_BOOLEAN) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_object (param_values + 1), g_value_get_object (param_values + 2), g_value_get_boolean (param_values + 3), data2);
}


static void g_cclosure_user_marshal_VOID__STRING_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__STRING_STRING) (gpointer data1, const char* arg_1, const char* arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_STRING callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_STRING) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_string (param_values + 2), data2);
}


static void connection_class_init (ConnectionClass * klass) {
	connection_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ConnectionPrivate));
	G_OBJECT_CLASS (klass)->finalize = connection_finalize;
	g_signal_new ("new_tab", TYPE_CONNECTION, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__OBJECT_STRING, G_TYPE_NONE, 2, TYPE_CHANNEL_TAB, G_TYPE_STRING);
	g_signal_new ("new_message", TYPE_CONNECTION, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__OBJECT_OBJECT_BOOLEAN, G_TYPE_NONE, 3, TYPE_CHANNEL_TAB, TYPE_MESSAGE, G_TYPE_BOOLEAN);
	g_signal_new ("change_channel_state", TYPE_CONNECTION, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_STRING, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_STRING);
}


static void connection_instance_init (Connection * self) {
	GeeHashMap* _tmp0_ = NULL;
	GeeLinkedList* _tmp1_ = NULL;
	self->priv = CONNECTION_GET_PRIVATE (self);
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, TYPE_CHANNEL_TAB, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	self->channel_tabs = _tmp0_;
	_tmp1_ = gee_linked_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL);
	self->channel_autoconnect = _tmp1_;
	self->exit = FALSE;
	self->error_state = FALSE;
	self->autoconnect_ran = FALSE;
}


static void connection_finalize (GObject* obj) {
	Connection * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CONNECTION, Connection);
	_g_object_unref0 (self->priv->input_stream);
	_g_object_unref0 (self->priv->output_stream);
	_g_object_unref0 (self->server_tab);
	_g_object_unref0 (self->channel_tabs);
	_g_object_unref0 (self->channel_autoconnect);
	_sql_client_server_unref0 (self->server);
	G_OBJECT_CLASS (connection_parent_class)->finalize (obj);
}


GType connection_get_type (void) {
	static volatile gsize connection_type_id__volatile = 0;
	if (g_once_init_enter (&connection_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ConnectionClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) connection_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Connection), 0, (GInstanceInitFunc) connection_instance_init, NULL };
		GType connection_type_id;
		connection_type_id = g_type_register_static (G_TYPE_OBJECT, "Connection", &g_define_type_info, 0);
		g_once_init_leave (&connection_type_id__volatile, connection_type_id);
	}
	return connection_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



