/* relay.c generated by valac 0.34.4, the Vala compiler
 * generated from relay.vala, do not modify */

/* -*- Mode: vala; indent-tabs-mode: nil; c-basic-offset: 4; tab-width: 4 -*-  */
/*
 * relay.vala
 * Copyright (C) 2015 Kyle Agronick <agronick@gmail.com>
 *
 * relay is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * relay is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.


TERMS OF USE - EASING EQUATIONS
pen source under  the http://www.opensource.org/licenses/bsd-license.php BSD License. <br>

Copyright Â© 2001 Robert Penner
All rights reserved.
Redistribution and use in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

Redistributions of source code must retain the above copyright  notice, this list of
conditions and the following disclaimer.
Redistributions in binary form must reproduce the above copyright notice, this list of
conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

Neither the name of the author nor the names of contributors may be used to
endorse or promote products derived from this software without specific
prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS
AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
*/

#include <glib.h>
#include <glib-object.h>
#include <granite.h>
#include <stdlib.h>
#include <string.h>
#include <X11/Xlib.h>
#include <X11/Xatom.h>
#include <X11/Xutil.h>
#include <X11/Xregion.h>
#include <gtk/gtk.h>
#include <gio/gio.h>
#include "config.h"
#include <stdio.h>
#include <glib/gi18n-lib.h>
#include <gdk/gdk.h>
#include <float.h>
#include <math.h>
#include <gee.h>
#include <locale.h>


#define TYPE_RELAY (relay_get_type ())
#define RELAY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RELAY, Relay))
#define RELAY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RELAY, RelayClass))
#define IS_RELAY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RELAY))
#define IS_RELAY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RELAY))
#define RELAY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RELAY, RelayClass))

typedef struct _Relay Relay;
typedef struct _RelayClass RelayClass;
typedef struct _RelayPrivate RelayPrivate;

#define TYPE_MAIN_WINDOW (main_window_get_type ())
#define MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAIN_WINDOW, MainWindow))
#define MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAIN_WINDOW, MainWindowClass))
#define IS_MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAIN_WINDOW))
#define IS_MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAIN_WINDOW))
#define MAIN_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAIN_WINDOW, MainWindowClass))

typedef struct _MainWindow MainWindow;
typedef struct _MainWindowClass MainWindowClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))
typedef struct _Block15Data Block15Data;
typedef struct _Block16Data Block16Data;

struct _Relay {
	GraniteApplication parent_instance;
	RelayPrivate * priv;
	gchar** args;
	gint args_length1;
};

struct _RelayClass {
	GraniteApplicationClass parent_class;
};

struct _RelayPrivate {
	MainWindow* window;
};

struct _Block15Data {
	int _ref_count_;
	gchar* error_msg;
};

struct _Block16Data {
	int _ref_count_;
	Block15Data * _data15_;
	GtkMessageDialog* dialog;
};


static gpointer relay_parent_class = NULL;
extern gboolean relay_has_activated;
gboolean relay_has_activated = FALSE;
extern gboolean relay_on_elementary;
gboolean relay_on_elementary = FALSE;
extern gboolean relay_on_ubuntu;
gboolean relay_on_ubuntu = FALSE;
extern gboolean relay_on_kde;
gboolean relay_on_kde = FALSE;
extern gboolean relay_is_light_theme;
gboolean relay_is_light_theme = FALSE;
extern gchar* relay_path;
gchar* relay_path = NULL;
extern gboolean relay_no_theme;
gboolean relay_no_theme = FALSE;
static gboolean relay_error_open;
static gboolean relay_error_open = FALSE;
extern GtkWindow* main_window_window;

GType relay_get_type (void) G_GNUC_CONST;
GType main_window_get_type (void) G_GNUC_CONST;
#define RELAY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_RELAY, RelayPrivate))
enum  {
	RELAY_DUMMY_PROPERTY
};
void relay_main (gchar** args, int args_length1);
void relay_handle_log (const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message);
static void _relay_handle_log_glog_func (const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message, gpointer self);
Relay* relay_new (void);
Relay* relay_construct (GType object_type);
static void relay_real_activate (GApplication* base);
static void relay_check_env (Relay* self);
MainWindow* main_window_new (Relay* application);
MainWindow* main_window_construct (GType object_type, Relay* application);
gchar* relay_get_asset_file (const gchar* name);
void relay_show_error_window (const gchar* error_msg);
static Block15Data* block15_data_ref (Block15Data* _data15_);
static void block15_data_unref (void * _userdata_);
static gboolean __lambda4_ (Block15Data* _data15_);
static Block16Data* block16_data_ref (Block16Data* _data16_);
static void block16_data_unref (void * _userdata_);
static void __lambda5_ (Block16Data* _data16_, gint response_id);
static void ___lambda5__gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self);
static gboolean ___lambda4__gsource_func (gpointer self);
gboolean relay_set_color_mode (GdkRGBA* color);
gdouble relay_ease_out_elastic (gfloat t, gfloat b, gfloat c, gfloat d);
gfloat relay_ease_in_bounce (gfloat t, gfloat b, gfloat c, gfloat d);
gfloat relay_ease_out_bounce (gfloat t, gfloat b, gfloat c, gfloat d);
void relay_sort_clean (GeeLinkedList** list);
gint relay_compare (const gchar* a, const gchar* b);
static gint _relay_compare_gcompare_data_func (gconstpointer a, gconstpointer b, gpointer self);
static GObject * relay_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void relay_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

const GOptionEntry RELAY_app_options[2] = {{"no-theme", 't', 0, G_OPTION_ARG_NONE, &relay_no_theme, "Disable switching to a different theme", NULL}, {NULL}};

static void _relay_handle_log_glog_func (const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message, gpointer self) {
	relay_handle_log (log_domain, log_levels, message);
}


void relay_main (gchar** args, int args_length1) {
	gchar** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	GOptionContext* context = NULL;
	GOptionContext* _tmp3_ = NULL;
	Relay* main = NULL;
	Relay* _tmp6_ = NULL;
	gchar** _tmp7_ = NULL;
	gint _tmp7__length1 = 0;
	GError * _inner_error_ = NULL;
	_tmp0_ = args;
	_tmp0__length1 = args_length1;
	_tmp1_ = _tmp0_[0];
	_tmp2_ = g_strdup (_tmp1_);
	_g_free0 (relay_path);
	relay_path = _tmp2_;
	_tmp3_ = g_option_context_new (NULL);
	context = _tmp3_;
	g_option_context_add_main_entries (context, RELAY_app_options, "relay");
	{
		g_option_context_parse (context, &args_length1, &args, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch8_g_error;
		}
	}
	goto __finally8;
	__catch8_g_error:
	{
		GError* e = NULL;
		GError* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp4_ = e;
		_tmp5_ = _tmp4_->message;
		g_warning ("relay.vala:120: %s", _tmp5_);
		_g_error_free0 (e);
	}
	__finally8:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_option_context_free0 (context);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	XInitThreads ();
	g_log_set_default_handler (_relay_handle_log_glog_func, NULL);
	_tmp6_ = relay_new ();
	main = _tmp6_;
	_tmp7_ = args;
	_tmp7__length1 = args_length1;
	granite_application_run ((GraniteApplication*) main, _tmp7_, _tmp7__length1);
	_g_object_unref0 (main);
	_g_option_context_free0 (context);
}


int main (int argc, char ** argv) {
#if !GLIB_CHECK_VERSION (2,35,0)
	g_type_init ();
#endif
	relay_main (argv, argc);
	return 0;
}


static void relay_real_activate (GApplication* base) {
	Relay * self;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp2_ = FALSE;
	GtkSettings* _tmp11_ = NULL;
	MainWindow* _tmp12_ = NULL;
	self = (Relay*) base;
	_tmp0_ = relay_has_activated;
	if (_tmp0_) {
		GtkWindow* _tmp1_ = NULL;
		_tmp1_ = main_window_window;
		gtk_window_present (_tmp1_);
		return;
	}
	relay_has_activated = TRUE;
	relay_check_env (self);
	_tmp2_ = relay_no_theme;
	if (!_tmp2_) {
		GFile* e_theme = NULL;
		GFile* _tmp3_ = NULL;
		GFile* _tmp4_ = NULL;
		gboolean _tmp5_ = FALSE;
		_tmp3_ = g_file_new_for_path ("/usr/share/themes/elementary/");
		e_theme = _tmp3_;
		_tmp4_ = e_theme;
		_tmp5_ = g_file_query_exists (_tmp4_, NULL);
		if (_tmp5_) {
			GtkSettings* _tmp6_ = NULL;
			_tmp6_ = gtk_settings_get_default ();
			g_object_set (_tmp6_, "gtk-theme-name", "elementary", NULL);
		} else {
			gboolean _tmp7_ = FALSE;
			_tmp7_ = relay_on_ubuntu;
			if (_tmp7_) {
				GtkSettings* _tmp8_ = NULL;
				_tmp8_ = gtk_settings_get_default ();
				g_object_set (_tmp8_, "gtk-theme-name", "Adwaita", NULL);
			} else {
				gboolean _tmp9_ = FALSE;
				_tmp9_ = relay_on_kde;
				if (_tmp9_) {
					GtkSettings* _tmp10_ = NULL;
					_tmp10_ = gtk_settings_get_default ();
					g_object_set (_tmp10_, "gtk-theme-name", "oxygen-gtk", NULL);
				}
			}
		}
		_g_object_unref0 (e_theme);
	} else {
		g_debug ("relay.vala:151: Not attempting to switch theme.");
	}
	_tmp11_ = gtk_settings_get_default ();
	g_object_set (_tmp11_, "gtk-application-prefer-dark-theme", TRUE, NULL);
	_tmp12_ = main_window_new (self);
	_g_object_unref0 (self->priv->window);
	self->priv->window = _tmp12_;
	gtk_main ();
}


gchar* relay_get_asset_file (const gchar* name) {
	gchar* result = NULL;
	gchar** checks = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	gchar** _tmp10_ = NULL;
	gint checks_length1 = 0;
	gint _checks_size_ = 0;
	gchar** _tmp11_ = NULL;
	gint _tmp11__length1 = 0;
	const gchar* _tmp17_ = NULL;
	gchar* _tmp18_ = NULL;
	gchar* _tmp19_ = NULL;
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = name;
	_tmp1_ = g_strconcat ("./", _tmp0_, NULL);
	_tmp2_ = name;
	_tmp3_ = g_strconcat ("src/", _tmp2_, NULL);
	_tmp4_ = name;
	_tmp5_ = g_strconcat ("../src/", _tmp4_, NULL);
	_tmp6_ = name;
	_tmp7_ = g_strconcat ("./*/src/", _tmp6_, NULL);
	_tmp8_ = name;
	_tmp9_ = g_strconcat (PACKAGE_DATA_DIR "/", _tmp8_, NULL);
	_tmp10_ = g_new0 (gchar*, 5 + 1);
	_tmp10_[0] = _tmp1_;
	_tmp10_[1] = _tmp3_;
	_tmp10_[2] = _tmp5_;
	_tmp10_[3] = _tmp7_;
	_tmp10_[4] = _tmp9_;
	checks = _tmp10_;
	checks_length1 = 5;
	_checks_size_ = checks_length1;
	_tmp11_ = checks;
	_tmp11__length1 = checks_length1;
	{
		gchar** check_collection = NULL;
		gint check_collection_length1 = 0;
		gint _check_collection_size_ = 0;
		gint check_it = 0;
		check_collection = _tmp11_;
		check_collection_length1 = _tmp11__length1;
		for (check_it = 0; check_it < _tmp11__length1; check_it = check_it + 1) {
			gchar* _tmp12_ = NULL;
			gchar* check = NULL;
			_tmp12_ = g_strdup (check_collection[check_it]);
			check = _tmp12_;
			{
				GFile* file = NULL;
				const gchar* _tmp13_ = NULL;
				GFile* _tmp14_ = NULL;
				GFile* _tmp15_ = NULL;
				gboolean _tmp16_ = FALSE;
				_tmp13_ = check;
				_tmp14_ = g_file_new_for_path (_tmp13_);
				file = _tmp14_;
				_tmp15_ = file;
				_tmp16_ = g_file_query_exists (_tmp15_, NULL);
				if (_tmp16_) {
					result = check;
					_g_object_unref0 (file);
					checks = (_vala_array_free (checks, checks_length1, (GDestroyNotify) g_free), NULL);
					return result;
				}
				_g_object_unref0 (file);
				_g_free0 (check);
			}
		}
	}
	_tmp17_ = name;
	_tmp18_ = g_strconcat ("Unable to find asset file: ", _tmp17_, NULL);
	_tmp19_ = _tmp18_;
	g_error ("relay.vala:171: %s", _tmp19_);
	_g_free0 (_tmp19_);
	checks = (_vala_array_free (checks, checks_length1, (GDestroyNotify) g_free), NULL);
}


void relay_handle_log (const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message) {
	gchar* prefix = NULL;
	gchar* _tmp0_ = NULL;
	gchar* suffix = NULL;
	gchar* _tmp1_ = NULL;
	GLogLevelFlags _tmp2_ = 0;
	FILE* _tmp9_ = NULL;
	const gchar* _tmp10_ = NULL;
	const gchar* _tmp11_ = NULL;
	gchar* _tmp12_ = NULL;
	gchar* _tmp13_ = NULL;
	const gchar* _tmp14_ = NULL;
	gchar* _tmp15_ = NULL;
	gchar* _tmp16_ = NULL;
	gchar* _tmp17_ = NULL;
	gchar* _tmp18_ = NULL;
	g_return_if_fail (message != NULL);
	_tmp0_ = g_strdup ("");
	prefix = _tmp0_;
	_tmp1_ = g_strdup ("\x1b[39;49m ");
	suffix = _tmp1_;
	_tmp2_ = log_levels;
	switch (_tmp2_) {
		case G_LOG_LEVEL_DEBUG:
		{
			gchar* _tmp3_ = NULL;
			_tmp3_ = g_strdup ("\x1b[94mDebug: ");
			_g_free0 (prefix);
			prefix = _tmp3_;
			break;
		}
		case G_LOG_LEVEL_INFO:
		{
			gchar* _tmp4_ = NULL;
			_tmp4_ = g_strdup ("\x1b[92mInfo: ");
			_g_free0 (prefix);
			prefix = _tmp4_;
			break;
		}
		case G_LOG_LEVEL_WARNING:
		{
			gchar* _tmp5_ = NULL;
			_tmp5_ = g_strdup ("\x1b[93mWarning: ");
			_g_free0 (prefix);
			prefix = _tmp5_;
			break;
		}
		case G_LOG_LEVEL_ERROR:
		{
			gchar* _tmp6_ = NULL;
			_tmp6_ = g_strdup ("\x1b[91mError: ");
			_g_free0 (prefix);
			prefix = _tmp6_;
			break;
		}
		default:
		{
			const gchar* _tmp7_ = NULL;
			gchar* _tmp8_ = NULL;
			_tmp7_ = message;
			_tmp8_ = g_strdup (_tmp7_);
			_g_free0 (prefix);
			prefix = _tmp8_;
			break;
		}
	}
	_tmp9_ = stdout;
	_tmp10_ = prefix;
	_tmp11_ = message;
	_tmp12_ = g_strconcat (_tmp10_, _tmp11_, NULL);
	_tmp13_ = _tmp12_;
	_tmp14_ = suffix;
	_tmp15_ = g_strconcat (_tmp13_, _tmp14_, NULL);
	_tmp16_ = _tmp15_;
	_tmp17_ = g_strconcat (_tmp16_, "\n", NULL);
	_tmp18_ = _tmp17_;
	fprintf (_tmp9_, "%s", _tmp18_);
	_g_free0 (_tmp18_);
	_g_free0 (_tmp16_);
	_g_free0 (_tmp13_);
	_g_free0 (suffix);
	_g_free0 (prefix);
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = needle;
	_tmp1_ = strstr ((gchar*) self, (gchar*) _tmp0_);
	result = _tmp1_ != NULL;
	return result;
}


static void relay_check_env (Relay* self) {
	gchar* output = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	const gchar* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_getenv ("XDG_CURRENT_DESKTOP");
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (output);
	output = _tmp1_;
	_tmp3_ = output;
	if (_tmp3_ != NULL) {
		const gchar* _tmp4_ = NULL;
		gboolean _tmp5_ = FALSE;
		_tmp4_ = output;
		_tmp5_ = string_contains (_tmp4_, "Pantheon");
		_tmp2_ = _tmp5_;
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		relay_on_elementary = TRUE;
	} else {
		gboolean _tmp6_ = FALSE;
		const gchar* _tmp7_ = NULL;
		_tmp7_ = output;
		if (_tmp7_ != NULL) {
			gboolean _tmp8_ = FALSE;
			const gchar* _tmp9_ = NULL;
			gboolean _tmp10_ = FALSE;
			_tmp9_ = output;
			_tmp10_ = string_contains (_tmp9_, "Unity");
			if (_tmp10_) {
				_tmp8_ = TRUE;
			} else {
				const gchar* _tmp11_ = NULL;
				gboolean _tmp12_ = FALSE;
				_tmp11_ = output;
				_tmp12_ = string_contains (_tmp11_, "XFCE");
				_tmp8_ = _tmp12_;
			}
			_tmp6_ = _tmp8_;
		} else {
			_tmp6_ = FALSE;
		}
		if (_tmp6_) {
			relay_on_ubuntu = TRUE;
		} else {
			const gchar* _tmp13_ = NULL;
			_tmp13_ = output;
			if (g_strcmp0 (_tmp13_, "KDE") == 0) {
				relay_on_kde = TRUE;
			}
		}
	}
	_g_free0 (output);
}


static Block15Data* block15_data_ref (Block15Data* _data15_) {
	g_atomic_int_inc (&_data15_->_ref_count_);
	return _data15_;
}


static void block15_data_unref (void * _userdata_) {
	Block15Data* _data15_;
	_data15_ = (Block15Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data15_->_ref_count_)) {
		_g_free0 (_data15_->error_msg);
		g_slice_free (Block15Data, _data15_);
	}
}


static Block16Data* block16_data_ref (Block16Data* _data16_) {
	g_atomic_int_inc (&_data16_->_ref_count_);
	return _data16_;
}


static void block16_data_unref (void * _userdata_) {
	Block16Data* _data16_;
	_data16_ = (Block16Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data16_->_ref_count_)) {
		_g_object_unref0 (_data16_->dialog);
		block15_data_unref (_data16_->_data15_);
		_data16_->_data15_ = NULL;
		g_slice_free (Block16Data, _data16_);
	}
}


static void __lambda5_ (Block16Data* _data16_, gint response_id) {
	Block15Data* _data15_;
	_data15_ = _data16_->_data15_;
	relay_error_open = FALSE;
	gtk_widget_destroy ((GtkWidget*) _data16_->dialog);
}


static void ___lambda5__gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self) {
	__lambda5_ (self, response_id);
}


static gboolean __lambda4_ (Block15Data* _data15_) {
	gboolean result = FALSE;
	Block16Data* _data16_;
	GtkWindow* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	GtkMessageDialog* _tmp3_ = NULL;
	_data16_ = g_slice_new0 (Block16Data);
	_data16_->_ref_count_ = 1;
	_data16_->_data15_ = block15_data_ref (_data15_);
	_tmp0_ = main_window_window;
	_tmp1_ = _data15_->error_msg;
	_tmp2_ = _ (_tmp1_);
	_tmp3_ = (GtkMessageDialog*) gtk_message_dialog_new (_tmp0_, GTK_DIALOG_MODAL, GTK_MESSAGE_WARNING, GTK_BUTTONS_OK, _tmp2_);
	g_object_ref_sink (_tmp3_);
	_data16_->dialog = _tmp3_;
	g_signal_connect_data ((GtkDialog*) _data16_->dialog, "response", (GCallback) ___lambda5__gtk_dialog_response, block16_data_ref (_data16_), (GClosureNotify) block16_data_unref, 0);
	gtk_widget_show ((GtkWidget*) _data16_->dialog);
	relay_error_open = TRUE;
	result = FALSE;
	block16_data_unref (_data16_);
	_data16_ = NULL;
	return result;
}


static gboolean ___lambda4__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda4_ (self);
	return result;
}


void relay_show_error_window (const gchar* error_msg) {
	Block15Data* _data15_;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	g_return_if_fail (error_msg != NULL);
	_data15_ = g_slice_new0 (Block15Data);
	_data15_->_ref_count_ = 1;
	_tmp0_ = error_msg;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (_data15_->error_msg);
	_data15_->error_msg = _tmp1_;
	_tmp2_ = relay_error_open;
	if (_tmp2_) {
		block15_data_unref (_data15_);
		_data15_ = NULL;
		return;
	}
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ___lambda4__gsource_func, block15_data_ref (_data15_), block15_data_unref);
	block15_data_unref (_data15_);
	_data15_ = NULL;
}


gboolean relay_set_color_mode (GdkRGBA* color) {
	gboolean result = FALSE;
	GdkRGBA _tmp0_ = {0};
	gdouble _tmp1_ = 0.0;
	GdkRGBA _tmp2_ = {0};
	gdouble _tmp3_ = 0.0;
	GdkRGBA _tmp4_ = {0};
	gdouble _tmp5_ = 0.0;
	gboolean _tmp6_ = FALSE;
	g_return_val_if_fail (color != NULL, FALSE);
	_tmp0_ = *color;
	_tmp1_ = _tmp0_.red;
	_tmp2_ = *color;
	_tmp3_ = _tmp2_.green;
	_tmp4_ = *color;
	_tmp5_ = _tmp4_.blue;
	relay_is_light_theme = (((0.2126 * _tmp1_) + (0.7152 * _tmp3_)) + (0.0722 * _tmp5_)) < 0.4;
	_tmp6_ = relay_is_light_theme;
	result = _tmp6_;
	return result;
}


gdouble relay_ease_out_elastic (gfloat t, gfloat b, gfloat c, gfloat d) {
	gdouble result = 0.0;
	gfloat _tmp0_ = 0.0F;
	gfloat _tmp2_ = 0.0F;
	gfloat _tmp3_ = 0.0F;
	gfloat _tmp4_ = 0.0F;
	gfloat p = 0.0F;
	gfloat _tmp7_ = 0.0F;
	gfloat a = 0.0F;
	gfloat _tmp8_ = 0.0F;
	gfloat s = 0.0F;
	gfloat _tmp9_ = 0.0F;
	gdouble val = 0.0;
	gfloat _tmp10_ = 0.0F;
	gfloat _tmp11_ = 0.0F;
	gdouble _tmp12_ = 0.0;
	gfloat _tmp13_ = 0.0F;
	gfloat _tmp14_ = 0.0F;
	gfloat _tmp15_ = 0.0F;
	gfloat _tmp16_ = 0.0F;
	gdouble _tmp17_ = 0.0;
	gfloat _tmp18_ = 0.0F;
	gfloat _tmp19_ = 0.0F;
	_tmp0_ = t;
	if (_tmp0_ == ((gfloat) 0)) {
		gfloat _tmp1_ = 0.0F;
		_tmp1_ = b;
		result = (gdouble) _tmp1_;
		return result;
	}
	_tmp2_ = t;
	_tmp3_ = d;
	t = _tmp2_ / _tmp3_;
	_tmp4_ = t;
	if (_tmp4_ == ((gfloat) 1)) {
		gfloat _tmp5_ = 0.0F;
		gfloat _tmp6_ = 0.0F;
		_tmp5_ = b;
		_tmp6_ = c;
		result = (gdouble) (_tmp5_ + _tmp6_);
		return result;
	}
	_tmp7_ = d;
	p = _tmp7_ * 0.3f;
	_tmp8_ = c;
	a = _tmp8_;
	_tmp9_ = p;
	s = _tmp9_ / 4;
	_tmp10_ = a;
	_tmp11_ = t;
	_tmp12_ = pow ((gdouble) 2, (gdouble) (-16 * _tmp11_));
	_tmp13_ = t;
	_tmp14_ = d;
	_tmp15_ = s;
	_tmp16_ = p;
	_tmp17_ = sin ((((_tmp13_ * _tmp14_) - _tmp15_) * (2 * G_PI)) / _tmp16_);
	_tmp18_ = c;
	_tmp19_ = b;
	val = (((_tmp10_ * _tmp12_) * _tmp17_) + _tmp18_) + _tmp19_;
	result = val;
	return result;
}


gfloat relay_ease_in_bounce (gfloat t, gfloat b, gfloat c, gfloat d) {
	gfloat result = 0.0F;
	gfloat _tmp0_ = 0.0F;
	gfloat _tmp1_ = 0.0F;
	gfloat _tmp2_ = 0.0F;
	gfloat _tmp3_ = 0.0F;
	gfloat _tmp4_ = 0.0F;
	gfloat _tmp5_ = 0.0F;
	gfloat _tmp6_ = 0.0F;
	_tmp0_ = c;
	_tmp1_ = d;
	_tmp2_ = t;
	_tmp3_ = c;
	_tmp4_ = d;
	_tmp5_ = relay_ease_out_bounce (_tmp1_ - _tmp2_, (gfloat) 0, _tmp3_, _tmp4_);
	_tmp6_ = b;
	result = (_tmp0_ - _tmp5_) + _tmp6_;
	return result;
}


gfloat relay_ease_out_bounce (gfloat t, gfloat b, gfloat c, gfloat d) {
	gfloat result = 0.0F;
	gfloat _tmp0_ = 0.0F;
	gfloat _tmp1_ = 0.0F;
	gfloat _tmp2_ = 0.0F;
	_tmp0_ = t;
	_tmp1_ = d;
	t = _tmp0_ / _tmp1_;
	_tmp2_ = t;
	if (_tmp2_ < (1 / 2.75f)) {
		gfloat _tmp3_ = 0.0F;
		gfloat _tmp4_ = 0.0F;
		gfloat _tmp5_ = 0.0F;
		gfloat _tmp6_ = 0.0F;
		_tmp3_ = c;
		_tmp4_ = t;
		_tmp5_ = t;
		_tmp6_ = b;
		result = (_tmp3_ * ((7.5625f * _tmp4_) * _tmp5_)) + _tmp6_;
		return result;
	} else {
		gfloat _tmp7_ = 0.0F;
		_tmp7_ = t;
		if (_tmp7_ < (2 / 2.75f)) {
			gfloat postFix = 0.0F;
			gfloat _tmp8_ = 0.0F;
			gfloat _tmp9_ = 0.0F;
			gfloat _tmp10_ = 0.0F;
			gfloat _tmp11_ = 0.0F;
			gfloat _tmp12_ = 0.0F;
			gfloat _tmp13_ = 0.0F;
			_tmp8_ = t;
			t = _tmp8_ - (1.5f / 2.75f);
			_tmp9_ = t;
			postFix = _tmp9_;
			_tmp10_ = c;
			_tmp11_ = postFix;
			_tmp12_ = t;
			_tmp13_ = b;
			result = (_tmp10_ * (((7.5625f * _tmp11_) * _tmp12_) + 0.75f)) + _tmp13_;
			return result;
		} else {
			gfloat _tmp14_ = 0.0F;
			_tmp14_ = t;
			if (((gdouble) _tmp14_) < (2.5 / 2.75)) {
				gfloat postFix = 0.0F;
				gfloat _tmp15_ = 0.0F;
				gfloat _tmp16_ = 0.0F;
				gfloat _tmp17_ = 0.0F;
				gfloat _tmp18_ = 0.0F;
				gfloat _tmp19_ = 0.0F;
				gfloat _tmp20_ = 0.0F;
				_tmp15_ = t;
				t = _tmp15_ - (2.25f / 2.75f);
				_tmp16_ = t;
				postFix = _tmp16_;
				_tmp17_ = c;
				_tmp18_ = postFix;
				_tmp19_ = t;
				_tmp20_ = b;
				result = (_tmp17_ * (((7.5625f * _tmp18_) * _tmp19_) + 0.9375f)) + _tmp20_;
				return result;
			} else {
				gfloat postFix = 0.0F;
				gfloat _tmp21_ = 0.0F;
				gfloat _tmp22_ = 0.0F;
				gfloat _tmp23_ = 0.0F;
				gfloat _tmp24_ = 0.0F;
				gfloat _tmp25_ = 0.0F;
				gfloat _tmp26_ = 0.0F;
				_tmp21_ = t;
				t = _tmp21_ - (2.625f / 2.75f);
				_tmp22_ = t;
				postFix = _tmp22_;
				_tmp23_ = c;
				_tmp24_ = postFix;
				_tmp25_ = t;
				_tmp26_ = b;
				result = (_tmp23_ * (((7.5625f * _tmp24_) * _tmp25_) + 0.984375f)) + _tmp26_;
				return result;
			}
		}
	}
}


static gint _relay_compare_gcompare_data_func (gconstpointer a, gconstpointer b, gpointer self) {
	gint result;
	result = relay_compare ((const gchar*) a, (const gchar*) b);
	return result;
}


void relay_sort_clean (GeeLinkedList** list) {
	GeeLinkedList* _tmp0_ = NULL;
	g_return_if_fail (*list != NULL);
	_tmp0_ = *list;
	gee_list_sort ((GeeList*) _tmp0_, _relay_compare_gcompare_data_func, NULL, NULL);
}


gint relay_compare (const gchar* a, const gchar* b) {
	gint result = 0;
	GCompareFunc _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gint _tmp7_ = 0;
	gint _tmp8_ = 0;
	g_return_val_if_fail (a != NULL, 0);
	g_return_val_if_fail (b != NULL, 0);
	_tmp0_ = g_strcmp0;
	_tmp1_ = a;
	_tmp2_ = g_utf8_strdown (_tmp1_, (gssize) -1);
	_tmp3_ = _tmp2_;
	_tmp4_ = b;
	_tmp5_ = g_utf8_strdown (_tmp4_, (gssize) -1);
	_tmp6_ = _tmp5_;
	_tmp7_ = _tmp0_ (_tmp3_, _tmp6_);
	_tmp8_ = _tmp7_;
	_g_free0 (_tmp6_);
	_g_free0 (_tmp3_);
	result = _tmp8_;
	return result;
}


Relay* relay_construct (GType object_type) {
	Relay * self = NULL;
	self = (Relay*) granite_application_construct (object_type);
	return self;
}


Relay* relay_new (void) {
	return relay_construct (TYPE_RELAY);
}


static GObject * relay_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	Relay * self;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	gchar* _tmp11_ = NULL;
	gchar* _tmp12_ = NULL;
	gchar** _tmp13_ = NULL;
	gchar* _tmp14_ = NULL;
	gchar** _tmp15_ = NULL;
	gchar* _tmp16_ = NULL;
	gchar** _tmp17_ = NULL;
	gchar* _tmp18_ = NULL;
	gchar* _tmp19_ = NULL;
	parent_class = G_OBJECT_CLASS (relay_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_RELAY, Relay);
	_tmp0_ = g_strdup ("Relay");
	_g_free0 (((GraniteApplication*) self)->program_name);
	((GraniteApplication*) self)->program_name = _tmp0_;
	_tmp1_ = g_strdup ("relay");
	_g_free0 (((GraniteApplication*) self)->exec_name);
	((GraniteApplication*) self)->exec_name = _tmp1_;
	_tmp2_ = g_strdup (PACKAGE_DATA_DIR);
	_g_free0 (((GraniteApplication*) self)->build_data_dir);
	((GraniteApplication*) self)->build_data_dir = _tmp2_;
	_tmp3_ = g_strdup (GETTEXT_PACKAGE);
	_g_free0 (((GraniteApplication*) self)->build_pkg_data_dir);
	((GraniteApplication*) self)->build_pkg_data_dir = _tmp3_;
	_tmp4_ = g_strdup (VERSION);
	_g_free0 (((GraniteApplication*) self)->build_version);
	((GraniteApplication*) self)->build_version = _tmp4_;
	_tmp5_ = g_strdup ("2015");
	_g_free0 (((GraniteApplication*) self)->app_years);
	((GraniteApplication*) self)->app_years = _tmp5_;
	_tmp6_ = g_strdup ("relay");
	_g_free0 (((GraniteApplication*) self)->app_icon);
	((GraniteApplication*) self)->app_icon = _tmp6_;
	_tmp7_ = g_strdup ("relay.desktop");
	_g_free0 (((GraniteApplication*) self)->app_launcher);
	((GraniteApplication*) self)->app_launcher = _tmp7_;
	g_application_set_application_id ((GApplication*) self, "net.launchpad.relay");
	_tmp8_ = g_strdup ("https://poisonpacket.wordpress.com/relay/");
	_g_free0 (((GraniteApplication*) self)->main_url);
	((GraniteApplication*) self)->main_url = _tmp8_;
	_tmp9_ = g_strdup ("https://bugs.launchpad.net/relay");
	_g_free0 (((GraniteApplication*) self)->bug_url);
	((GraniteApplication*) self)->bug_url = _tmp9_;
	_tmp10_ = g_strdup ("https://poisonpacket.wordpress.com/relay/");
	_g_free0 (((GraniteApplication*) self)->help_url);
	((GraniteApplication*) self)->help_url = _tmp10_;
	_tmp11_ = g_strdup ("https://translations.launchpad.net/relay");
	_g_free0 (((GraniteApplication*) self)->translate_url);
	((GraniteApplication*) self)->translate_url = _tmp11_;
	_tmp12_ = g_strdup ("Kyle Agronick <agronick@gmail.com>");
	_tmp13_ = g_new0 (gchar*, 1 + 1);
	_tmp13_[0] = _tmp12_;
	((GraniteApplication*) self)->about_authors = (_vala_array_free (((GraniteApplication*) self)->about_authors, ((GraniteApplication*) self)->about_authors_length1, (GDestroyNotify) g_free), NULL);
	((GraniteApplication*) self)->about_authors = _tmp13_;
	((GraniteApplication*) self)->about_authors_length1 = 1;
	_tmp14_ = g_strdup ("Kyle Agronick <agronick@gmail.com>");
	_tmp15_ = g_new0 (gchar*, 1 + 1);
	_tmp15_[0] = _tmp14_;
	((GraniteApplication*) self)->about_documenters = (_vala_array_free (((GraniteApplication*) self)->about_documenters, ((GraniteApplication*) self)->about_documenters_length1, (GDestroyNotify) g_free), NULL);
	((GraniteApplication*) self)->about_documenters = _tmp15_;
	((GraniteApplication*) self)->about_documenters_length1 = 1;
	_tmp16_ = g_strdup ("Kyle Agronick (App) <agronick@gmail.com>");
	_tmp17_ = g_new0 (gchar*, 1 + 1);
	_tmp17_[0] = _tmp16_;
	((GraniteApplication*) self)->about_artists = (_vala_array_free (((GraniteApplication*) self)->about_artists, ((GraniteApplication*) self)->about_artists_length1, (GDestroyNotify) g_free), NULL);
	((GraniteApplication*) self)->about_artists = _tmp17_;
	((GraniteApplication*) self)->about_artists_length1 = 1;
	_tmp18_ = g_strdup ("IRC Client for the Modern Desktop");
	_g_free0 (((GraniteApplication*) self)->about_comments);
	((GraniteApplication*) self)->about_comments = _tmp18_;
	_tmp19_ = g_strdup ("translator-credits");
	_g_free0 (((GraniteApplication*) self)->about_translators);
	((GraniteApplication*) self)->about_translators = _tmp19_;
	((GraniteApplication*) self)->about_license_type = GTK_LICENSE_GPL_3_0;
	granite_application_set_options ((GraniteApplication*) self);
	setlocale (LC_MESSAGES, "");
	textdomain (GETTEXT_PACKAGE);
	bind_textdomain_codeset (GETTEXT_PACKAGE, "utf-8");
	bindtextdomain (GETTEXT_PACKAGE, "./locale");
	return obj;
}


static void relay_class_init (RelayClass * klass) {
	relay_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (RelayPrivate));
	((GApplicationClass *) klass)->activate = relay_real_activate;
	G_OBJECT_CLASS (klass)->constructor = relay_constructor;
	G_OBJECT_CLASS (klass)->finalize = relay_finalize;
}


static void relay_instance_init (Relay * self) {
	self->priv = RELAY_GET_PRIVATE (self);
	self->priv->window = NULL;
}


static void relay_finalize (GObject* obj) {
	Relay * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_RELAY, Relay);
	_g_object_unref0 (self->priv->window);
	self->args = (_vala_array_free (self->args, self->args_length1, (GDestroyNotify) g_free), NULL);
	G_OBJECT_CLASS (relay_parent_class)->finalize (obj);
}


GType relay_get_type (void) {
	static volatile gsize relay_type_id__volatile = 0;
	if (g_once_init_enter (&relay_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (RelayClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) relay_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Relay), 0, (GInstanceInitFunc) relay_instance_init, NULL };
		GType relay_type_id;
		relay_type_id = g_type_register_static (GRANITE_TYPE_APPLICATION, "Relay", &g_define_type_info, 0);
		g_once_init_leave (&relay_type_id__volatile, relay_type_id);
	}
	return relay_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



